<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>deeplenstronomy.image_generator API documentation</title>
<meta name="description" content="Generate images from the organized user inputs." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>deeplenstronomy.image_generator</code></h1>
</header>
<section id="section-intro">
<p>Generate images from the organized user inputs.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Generate images from the organized user inputs.&#34;&#34;&#34;

from astropy.cosmology import FlatLambdaCDM
from lenstronomy.SimulationAPI.sim_api import SimAPI
from lenstronomy.LensModel.Solver import lens_equation_solver
import numpy as np

import deeplenstronomy.distributions as distributions

from deeplenstronomy.utils import dict_select, dict_select_choose, select_params


class ImageGenerator():
    def __init__(self, return_planes=False, solve_lens_equation=False):
        &#34;&#34;&#34;
        This is an internal class which calls lenstronomy functions based on parsed user inputs.
        
        Args:
            return_planes (bool): Automatically passed from deeplenstronomy.make_dataset args
            solve_lens_equation (bool): Automatically passed from deeplenstronomy.make_dataset args

        &#34;&#34;&#34;
        self.return_planes = return_planes
        self.solve_lens_equation = solve_lens_equation
        return
    
    def sim_image(self, info_dict):
        &#34;&#34;&#34;
        Simulate an image based on specifications in sim_dict
        
        Args:
            info_dict (dict): A single element from the list produced interanlly by input_reader.Organizer.breakup(). 
                Contains all the properties of a single image to generate.
        &#34;&#34;&#34;
        output_image = []
        if self.return_planes:
            output_source, output_lens, output_point_source, output_noise = [], [], [], []
        output_metadata = []
        
        #set the cosmology
        cosmology_info = [&#39;H0&#39;, &#39;Om0&#39;, &#39;Tcmb0&#39;, &#39;Neff&#39;, &#39;m_nu&#39;, &#39;Ob0&#39;]
        cosmo = FlatLambdaCDM(**dict_select_choose(list(info_dict.values())[0], cosmology_info))
        
        for band, sim_dict in info_dict.items():
            ### Geometry-independent image properties
            
            # Single Band Info
            single_band_info = [&#39;read_noise&#39;, &#39;pixel_scale&#39;, &#39;ccd_gain&#39;, &#39;exposure_time&#39;,
                                &#39;sky_brightness&#39;, &#39;seeing&#39;, &#39;magnitude_zero_point&#39;,
                                &#39;num_exposures&#39;, &#39;data_count_unit&#39;, &#39;background_noise&#39;]
            kwargs_single_band = dict_select_choose(sim_dict, single_band_info)
            
            # Extinction
            extinction_class = None  #figure this out later
            
            # Numerics -- only use single number kwargs
            numerics_info = [&#39;supersampling_factor&#39;, &#39;compute_mode&#39;, &#39;supersampling_convolution&#39;,
                             &#39;supersampling_kernel_size&#39;, &#39;point_source_supersampling_factor&#39;, 
                             &#39;convolution_kernel_size&#39;]
            kwargs_numerics = dict_select_choose(sim_dict, numerics_info)
            
            ### Geometry-dependent image properties
            
            # Dictionary for physical model
            kwargs_model = {&#39;lens_model_list&#39;: [],  # list of lens models to be used
                            &#39;lens_redshift_list&#39;: [],  # list of redshift of the deflections
                            &#39;lens_light_model_list&#39;: [],  # list of unlensed light models to be used
                            &#39;source_light_model_list&#39;: [],  # list of extended source models to be used
                            &#39;source_redshift_list&#39;: [],  # list of redshfits of the sources in same order as source_light_model_list
                            &#39;point_source_model_list&#39;: [], # list of point source models
                            &#39;cosmo&#39;: cosmo,
                            &#39;z_source&#39;: 0.0}

            # Lists for model kwargs
            kwargs_source_list, kwargs_lens_model_list, kwargs_lens_light_list, kwargs_point_source_list = [], [], [], []
            
            for plane_num in range(1, sim_dict[&#39;NUMBER_OF_PLANES&#39;] + 1):
                
                for obj_num in range(1, sim_dict[&#39;PLANE_{0}-NUMBER_OF_OBJECTS&#39;.format(plane_num)] + 1):
                    
                    prefix = &#39;PLANE_{0}-OBJECT_{1}-&#39;.format(plane_num, obj_num)
                    
                    ### Point sources
                    if sim_dict[prefix + &#39;HOST&#39;] != &#39;None&#39;:
                        
                        # Foreground objects
                        if sim_dict[prefix + &#39;HOST&#39;] == &#39;Foreground&#39;:
                            kwargs_model[&#39;point_source_model_list&#39;].append(&#39;UNLENSED&#39;)
                            ps_info = [&#39;PLANE_{0}-OBJECT_{1}-{2}&#39;.format(plane_num, obj_num, x) for x in [&#39;ra_image&#39;, &#39;dec_image&#39;, &#39;magnitude&#39;]]
                            ps_dict_info = dict_select(sim_dict, ps_info)
                            kwargs_point_source_list.append({&#39;ra_image&#39;: [ps_dict_info[prefix + &#39;ra_image&#39;]], &#39;dec_image&#39;: [ps_dict_info[prefix + &#39;dec_image&#39;]], &#39;magnitude&#39;: [ps_dict_info[prefix + &#39;magnitude&#39;]]})
                        # Real point sources
                        else:
                            if plane_num &lt; sim_dict[&#39;NUMBER_OF_PLANES&#39;]:
                                # point sources in the lens
                                kwargs_model[&#39;point_source_model_list&#39;].append(&#39;LENSED_POSITION&#39;)
                                ps_info = [&#39;PLANE_{0}-OBJECT_{1}-{2}&#39;.format(plane_num, obj_num, x) for x in [&#39;ra&#39;, &#39;dec&#39;, &#39;magnitude&#39;]]
                                ps_dict_info = dict_select(sim_dict, ps_info)
                                kwargs_point_source_list.append({&#39;ra_image&#39;: [ps_dict_info[prefix + &#39;ra&#39;]],
                                                                 &#39;dec_image&#39;: [ps_dict_info[prefix + &#39;dec&#39;]],
                                                                 &#39;magnitude&#39;: [ps_dict_info[prefix + &#39;magnitude&#39;]]})
                            elif plane_num == sim_dict[&#39;NUMBER_OF_PLANES&#39;]:
                                # point sources in the source plane
                                kwargs_model[&#39;point_source_model_list&#39;].append(&#39;SOURCE_POSITION&#39;)
                                ps_info = [&#39;PLANE_{0}-OBJECT_{1}-{2}&#39;.format(plane_num, obj_num, x) for x in [&#39;ra&#39;, &#39;dec&#39;, &#39;magnitude&#39;]]
                                ps_dict_info = dict_select(sim_dict, ps_info)
                                kwargs_point_source_list.append({&#39;ra_source&#39;: ps_dict_info[&#39;PLANE_{0}-OBJECT_{1}-ra&#39;.format(plane_num, obj_num)], 
                                                                 &#39;dec_source&#39;: ps_dict_info[&#39;PLANE_{0}-OBJECT_{1}-dec&#39;.format(plane_num, obj_num)], 
                                                                 &#39;magnitude&#39;: ps_dict_info[&#39;PLANE_{0}-OBJECT_{1}-magnitude&#39;.format(plane_num, obj_num)]})
                            else:
                                #should never get here
                                assert False
                                
                        # the number of profiles will be zero for point sources, so just skip ahead
                        continue
                    
                    ### Model keywords
                    # All planes except last one - treat as lens
                    if plane_num &lt; sim_dict[&#39;NUMBER_OF_PLANES&#39;]:
                        for light_profile_num in range(1, sim_dict[prefix + &#39;NUMBER_OF_LIGHT_PROFILES&#39;] +1):
                            kwargs_model[&#39;lens_light_model_list&#39;].append(sim_dict[prefix + &#39;LIGHT_PROFILE_{0}-NAME&#39;.format(light_profile_num)])
                            #kwargs_model[&#39;lens_redshift_list&#39;].append(sim_dict[prefix + &#39;REDSHIFT&#39;])
                            kwargs_lens_light_list.append(select_params(sim_dict, prefix + &#39;LIGHT_PROFILE_{0}-&#39;.format(light_profile_num)))
                        for mass_profile_num in range(1, sim_dict[prefix + &#39;NUMBER_OF_MASS_PROFILES&#39;] +1):
                            kwargs_model[&#39;lens_model_list&#39;].append(sim_dict[prefix + &#39;MASS_PROFILE_{0}-NAME&#39;.format(mass_profile_num)])
                            kwargs_model[&#39;lens_redshift_list&#39;].append(sim_dict[prefix + &#39;REDSHIFT&#39;])
                            mass_params = select_params(sim_dict, prefix + &#39;MASS_PROFILE_{0}-&#39;.format(mass_profile_num))
                            kwargs_lens_model_list.append(mass_params)
                            if &#39;sigma_v&#39; in mass_params.keys(): # save simga_v locations so that we can calculate theta_E for the metadata
                                output_metadata.append({&#39;PARAM_NAME&#39;:  prefix + &#39;MASS_PROFILE_{0}-sigma_v-{1}&#39;.format(mass_profile_num, band),
                                                        &#39;PARAM_VALUE&#39;: mass_params[&#39;sigma_v&#39;],
                                                        &#39;LENS_MODEL_IDX&#39;: len(kwargs_lens_model_list) - 1})
                        for shear_profile_num in range(1, sim_dict[prefix + &#39;NUMBER_OF_SHEAR_PROFILES&#39;] +1):
                            kwargs_model[&#39;lens_model_list&#39;].append(sim_dict[prefix + &#39;SHEAR_PROFILE_{0}-NAME&#39;.format(shear_profile_num)])
                            kwargs_model[&#39;lens_redshift_list&#39;].append(sim_dict[prefix + &#39;REDSHIFT&#39;])
                            mass_params = select_params(sim_dict, prefix + &#39;SHEAR_PROFILE_{0}-&#39;.format(shear_profile_num))
                            kwargs_lens_model_list.append(select_params(sim_dict, prefix + &#39;SHEAR_PROFILE_{0}-&#39;.format(shear_profile_num)))
                                                   
                    # Last Plane - treat as source
                    elif plane_num == sim_dict[&#39;NUMBER_OF_PLANES&#39;]:
                        kwargs_model[&#39;z_source&#39;] = sim_dict[prefix + &#39;REDSHIFT&#39;]
                        for light_profile_num in range(1, sim_dict[prefix + &#39;NUMBER_OF_LIGHT_PROFILES&#39;] +1):
                            kwargs_model[&#39;source_light_model_list&#39;].append(sim_dict[prefix + &#39;LIGHT_PROFILE_{0}-NAME&#39;.format(light_profile_num)])
                            kwargs_model[&#39;source_redshift_list&#39;].append(sim_dict[prefix + &#39;REDSHIFT&#39;])
                            kwargs_source_list.append(select_params(sim_dict, prefix + &#39;LIGHT_PROFILE_{0}-&#39;.format(light_profile_num)))
                        
                    else:
                        # Should never get here
                        assert False

            # Make image
            sim = SimAPI(numpix=sim_dict[&#39;numPix&#39;], 
                         kwargs_single_band=kwargs_single_band, 
                         kwargs_model=kwargs_model)

            imSim = sim.image_model_class(kwargs_numerics)
            
            kwargs_lens_light_list, kwargs_source_list, kwargs_point_source_list = sim.magnitude2amplitude(kwargs_lens_light_mag=kwargs_lens_light_list,
                                                                                                           kwargs_source_mag=kwargs_source_list,
                                                                                                           kwargs_ps_mag=kwargs_point_source_list)
            
            kwargs_lens_model_list = sim.physical2lensing_conversion(kwargs_mass=kwargs_lens_model_list)
            # Save theta_E (and sigma_v if used)
            for ii in range(len(output_metadata)):
                output_metadata.append({&#39;PARAM_NAME&#39;: output_metadata[ii][&#39;PARAM_NAME&#39;].replace(&#39;sigma_v&#39;, &#39;theta_E&#39;),
                                        &#39;PARAM_VALUE&#39;: kwargs_lens_model_list[output_metadata[ii][&#39;LENS_MODEL_IDX&#39;]][&#39;theta_E&#39;],
                                        &#39;LENS_MODEL_IDX&#39;: output_metadata[ii][&#39;LENS_MODEL_IDX&#39;]})
                
            try:
                image = imSim.image(kwargs_lens=kwargs_lens_model_list,
                                    kwargs_lens_light=kwargs_lens_light_list,
                                    kwargs_source=kwargs_source_list,
                                    kwargs_ps=kwargs_point_source_list)
            except Exception:
                # Some sort of lenstronomy error
                print(&#34;kwargs_numerics&#34;, kwargs_numerics)
                print(&#34;kwargs_single_band&#34;, kwargs_single_band)
                print(&#34;kwargs_model&#34;, kwargs_model)
                print(&#34;kwargs_lens_model_list&#34;, kwargs_lens_model_list)
                print(&#34;kwargs_lens_light_list&#34;, kwargs_lens_light_list)
                print(&#34;kwargs_source_list&#34;, kwargs_source_list)
                print(&#34;kwargs_point_source_list&#34;, kwargs_point_source_list)
                assert False
                                
            # Solve lens equation if desired
            if self.solve_lens_equation:
                solver = lens_equation_solver.LensEquationSolver(imSim.LensModel)
                x_mins, y_mins = solver.image_position_from_source(sourcePos_x=kwargs_source_list[0][&#39;center_x&#39;],
                                                                   sourcePos_y=kwargs_source_list[0][&#39;center_y&#39;],
                                                                   kwargs_lens=kwargs_lens_model_list)
                num_source_images = len(x_mins)
            
            # Add noise
            image_noise = np.zeros(np.shape(image))
            for noise_source_num in range(1, sim_dict[&#39;NUMBER_OF_NOISE_SOURCES&#39;] + 1):
                image_noise += self._generate_noise(sim_dict[&#39;NOISE_SOURCE_{0}-NAME&#39;.format(noise_source_num)],
                                                    np.shape(image),
                                                    select_params(sim_dict, &#39;NOISE_SOURCE_{0}-&#39;.format(noise_source_num)))
            image += image_noise
                
            # Combine with other bands
            output_image.append(image)

            # Store plane-separated info if requested
            if self.return_planes:
                output_lens.append(imSim.lens_surface_brightness(kwargs_lens_light_list))
                output_source.append(imSim.source_surface_brightness(kwargs_source_list, kwargs_lens_model_list))
                output_point_source.append(imSim.point_source(kwargs_point_source_list, kwargs_lens_model_list))
                output_noise.append(image_noise)
        
        # Return the desired information in a dictionary
        return_dict = {&#39;output_image&#39;: np.array(output_image),
                       &#39;output_lens_plane&#39;: None,
                       &#39;output_source_plane&#39;: None,
                       &#39;output_point_source_plane&#39;: None,
                       &#39;output_noise_plane&#39;: None,
                       &#39;x_mins&#39;: None,
                       &#39;y_mins&#39;: None,
                       &#39;num_source_images&#39;: None,
                       &#39;additional_metadata&#39;: output_metadata}
        if self.return_planes:
            return_dict[&#39;output_lens_plane&#39;] = np.array(output_lens)
            return_dict[&#39;output_source_plane&#39;] = np.array(output_source)
            return_dict[&#39;output_point_source_plane&#39;] = np.array(output_point_source)
            return_dict[&#39;output_noise_plane&#39;] = np.array(output_noise)
        if self.solve_lens_equation:
            return_dict[&#39;x_mins&#39;] = x_mins
            return_dict[&#39;y_mins&#39;] = y_mins
            return_dict[&#39;num_source_images&#39;] = num_source_images

        return return_dict

    def _generate_noise(self, name, shape, params):
        &#34;&#34;&#34;
        Add noise to image based on input yaml by targeting specified distribution.
        
        :param name: name of the distribution to target
        :param shape: shape of image to add noise to
        :param params: dictionary of additional parameters needed by distributions.name()
        :return: noise_image: noise from targeted distribution for the image
        &#34;&#34;&#34;
        return eval(&#39;distributions.{0}(shape, **params)&#39;.format(name.lower()))

    

                        </code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="deeplenstronomy.image_generator.ImageGenerator"><code class="flex name class">
<span>class <span class="ident">ImageGenerator</span></span>
<span>(</span><span>return_planes=False, solve_lens_equation=False)</span>
</code></dt>
<dd>
<div class="desc"><p>This is an internal class which calls lenstronomy functions based on parsed user inputs.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>return_planes</code></strong> :&ensp;<code>bool</code></dt>
<dd>Automatically passed from deeplenstronomy.make_dataset args</dd>
<dt><strong><code>solve_lens_equation</code></strong> :&ensp;<code>bool</code></dt>
<dd>Automatically passed from deeplenstronomy.make_dataset args</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ImageGenerator():
    def __init__(self, return_planes=False, solve_lens_equation=False):
        &#34;&#34;&#34;
        This is an internal class which calls lenstronomy functions based on parsed user inputs.
        
        Args:
            return_planes (bool): Automatically passed from deeplenstronomy.make_dataset args
            solve_lens_equation (bool): Automatically passed from deeplenstronomy.make_dataset args

        &#34;&#34;&#34;
        self.return_planes = return_planes
        self.solve_lens_equation = solve_lens_equation
        return
    
    def sim_image(self, info_dict):
        &#34;&#34;&#34;
        Simulate an image based on specifications in sim_dict
        
        Args:
            info_dict (dict): A single element from the list produced interanlly by input_reader.Organizer.breakup(). 
                Contains all the properties of a single image to generate.
        &#34;&#34;&#34;
        output_image = []
        if self.return_planes:
            output_source, output_lens, output_point_source, output_noise = [], [], [], []
        output_metadata = []
        
        #set the cosmology
        cosmology_info = [&#39;H0&#39;, &#39;Om0&#39;, &#39;Tcmb0&#39;, &#39;Neff&#39;, &#39;m_nu&#39;, &#39;Ob0&#39;]
        cosmo = FlatLambdaCDM(**dict_select_choose(list(info_dict.values())[0], cosmology_info))
        
        for band, sim_dict in info_dict.items():
            ### Geometry-independent image properties
            
            # Single Band Info
            single_band_info = [&#39;read_noise&#39;, &#39;pixel_scale&#39;, &#39;ccd_gain&#39;, &#39;exposure_time&#39;,
                                &#39;sky_brightness&#39;, &#39;seeing&#39;, &#39;magnitude_zero_point&#39;,
                                &#39;num_exposures&#39;, &#39;data_count_unit&#39;, &#39;background_noise&#39;]
            kwargs_single_band = dict_select_choose(sim_dict, single_band_info)
            
            # Extinction
            extinction_class = None  #figure this out later
            
            # Numerics -- only use single number kwargs
            numerics_info = [&#39;supersampling_factor&#39;, &#39;compute_mode&#39;, &#39;supersampling_convolution&#39;,
                             &#39;supersampling_kernel_size&#39;, &#39;point_source_supersampling_factor&#39;, 
                             &#39;convolution_kernel_size&#39;]
            kwargs_numerics = dict_select_choose(sim_dict, numerics_info)
            
            ### Geometry-dependent image properties
            
            # Dictionary for physical model
            kwargs_model = {&#39;lens_model_list&#39;: [],  # list of lens models to be used
                            &#39;lens_redshift_list&#39;: [],  # list of redshift of the deflections
                            &#39;lens_light_model_list&#39;: [],  # list of unlensed light models to be used
                            &#39;source_light_model_list&#39;: [],  # list of extended source models to be used
                            &#39;source_redshift_list&#39;: [],  # list of redshfits of the sources in same order as source_light_model_list
                            &#39;point_source_model_list&#39;: [], # list of point source models
                            &#39;cosmo&#39;: cosmo,
                            &#39;z_source&#39;: 0.0}

            # Lists for model kwargs
            kwargs_source_list, kwargs_lens_model_list, kwargs_lens_light_list, kwargs_point_source_list = [], [], [], []
            
            for plane_num in range(1, sim_dict[&#39;NUMBER_OF_PLANES&#39;] + 1):
                
                for obj_num in range(1, sim_dict[&#39;PLANE_{0}-NUMBER_OF_OBJECTS&#39;.format(plane_num)] + 1):
                    
                    prefix = &#39;PLANE_{0}-OBJECT_{1}-&#39;.format(plane_num, obj_num)
                    
                    ### Point sources
                    if sim_dict[prefix + &#39;HOST&#39;] != &#39;None&#39;:
                        
                        # Foreground objects
                        if sim_dict[prefix + &#39;HOST&#39;] == &#39;Foreground&#39;:
                            kwargs_model[&#39;point_source_model_list&#39;].append(&#39;UNLENSED&#39;)
                            ps_info = [&#39;PLANE_{0}-OBJECT_{1}-{2}&#39;.format(plane_num, obj_num, x) for x in [&#39;ra_image&#39;, &#39;dec_image&#39;, &#39;magnitude&#39;]]
                            ps_dict_info = dict_select(sim_dict, ps_info)
                            kwargs_point_source_list.append({&#39;ra_image&#39;: [ps_dict_info[prefix + &#39;ra_image&#39;]], &#39;dec_image&#39;: [ps_dict_info[prefix + &#39;dec_image&#39;]], &#39;magnitude&#39;: [ps_dict_info[prefix + &#39;magnitude&#39;]]})
                        # Real point sources
                        else:
                            if plane_num &lt; sim_dict[&#39;NUMBER_OF_PLANES&#39;]:
                                # point sources in the lens
                                kwargs_model[&#39;point_source_model_list&#39;].append(&#39;LENSED_POSITION&#39;)
                                ps_info = [&#39;PLANE_{0}-OBJECT_{1}-{2}&#39;.format(plane_num, obj_num, x) for x in [&#39;ra&#39;, &#39;dec&#39;, &#39;magnitude&#39;]]
                                ps_dict_info = dict_select(sim_dict, ps_info)
                                kwargs_point_source_list.append({&#39;ra_image&#39;: [ps_dict_info[prefix + &#39;ra&#39;]],
                                                                 &#39;dec_image&#39;: [ps_dict_info[prefix + &#39;dec&#39;]],
                                                                 &#39;magnitude&#39;: [ps_dict_info[prefix + &#39;magnitude&#39;]]})
                            elif plane_num == sim_dict[&#39;NUMBER_OF_PLANES&#39;]:
                                # point sources in the source plane
                                kwargs_model[&#39;point_source_model_list&#39;].append(&#39;SOURCE_POSITION&#39;)
                                ps_info = [&#39;PLANE_{0}-OBJECT_{1}-{2}&#39;.format(plane_num, obj_num, x) for x in [&#39;ra&#39;, &#39;dec&#39;, &#39;magnitude&#39;]]
                                ps_dict_info = dict_select(sim_dict, ps_info)
                                kwargs_point_source_list.append({&#39;ra_source&#39;: ps_dict_info[&#39;PLANE_{0}-OBJECT_{1}-ra&#39;.format(plane_num, obj_num)], 
                                                                 &#39;dec_source&#39;: ps_dict_info[&#39;PLANE_{0}-OBJECT_{1}-dec&#39;.format(plane_num, obj_num)], 
                                                                 &#39;magnitude&#39;: ps_dict_info[&#39;PLANE_{0}-OBJECT_{1}-magnitude&#39;.format(plane_num, obj_num)]})
                            else:
                                #should never get here
                                assert False
                                
                        # the number of profiles will be zero for point sources, so just skip ahead
                        continue
                    
                    ### Model keywords
                    # All planes except last one - treat as lens
                    if plane_num &lt; sim_dict[&#39;NUMBER_OF_PLANES&#39;]:
                        for light_profile_num in range(1, sim_dict[prefix + &#39;NUMBER_OF_LIGHT_PROFILES&#39;] +1):
                            kwargs_model[&#39;lens_light_model_list&#39;].append(sim_dict[prefix + &#39;LIGHT_PROFILE_{0}-NAME&#39;.format(light_profile_num)])
                            #kwargs_model[&#39;lens_redshift_list&#39;].append(sim_dict[prefix + &#39;REDSHIFT&#39;])
                            kwargs_lens_light_list.append(select_params(sim_dict, prefix + &#39;LIGHT_PROFILE_{0}-&#39;.format(light_profile_num)))
                        for mass_profile_num in range(1, sim_dict[prefix + &#39;NUMBER_OF_MASS_PROFILES&#39;] +1):
                            kwargs_model[&#39;lens_model_list&#39;].append(sim_dict[prefix + &#39;MASS_PROFILE_{0}-NAME&#39;.format(mass_profile_num)])
                            kwargs_model[&#39;lens_redshift_list&#39;].append(sim_dict[prefix + &#39;REDSHIFT&#39;])
                            mass_params = select_params(sim_dict, prefix + &#39;MASS_PROFILE_{0}-&#39;.format(mass_profile_num))
                            kwargs_lens_model_list.append(mass_params)
                            if &#39;sigma_v&#39; in mass_params.keys(): # save simga_v locations so that we can calculate theta_E for the metadata
                                output_metadata.append({&#39;PARAM_NAME&#39;:  prefix + &#39;MASS_PROFILE_{0}-sigma_v-{1}&#39;.format(mass_profile_num, band),
                                                        &#39;PARAM_VALUE&#39;: mass_params[&#39;sigma_v&#39;],
                                                        &#39;LENS_MODEL_IDX&#39;: len(kwargs_lens_model_list) - 1})
                        for shear_profile_num in range(1, sim_dict[prefix + &#39;NUMBER_OF_SHEAR_PROFILES&#39;] +1):
                            kwargs_model[&#39;lens_model_list&#39;].append(sim_dict[prefix + &#39;SHEAR_PROFILE_{0}-NAME&#39;.format(shear_profile_num)])
                            kwargs_model[&#39;lens_redshift_list&#39;].append(sim_dict[prefix + &#39;REDSHIFT&#39;])
                            mass_params = select_params(sim_dict, prefix + &#39;SHEAR_PROFILE_{0}-&#39;.format(shear_profile_num))
                            kwargs_lens_model_list.append(select_params(sim_dict, prefix + &#39;SHEAR_PROFILE_{0}-&#39;.format(shear_profile_num)))
                                                   
                    # Last Plane - treat as source
                    elif plane_num == sim_dict[&#39;NUMBER_OF_PLANES&#39;]:
                        kwargs_model[&#39;z_source&#39;] = sim_dict[prefix + &#39;REDSHIFT&#39;]
                        for light_profile_num in range(1, sim_dict[prefix + &#39;NUMBER_OF_LIGHT_PROFILES&#39;] +1):
                            kwargs_model[&#39;source_light_model_list&#39;].append(sim_dict[prefix + &#39;LIGHT_PROFILE_{0}-NAME&#39;.format(light_profile_num)])
                            kwargs_model[&#39;source_redshift_list&#39;].append(sim_dict[prefix + &#39;REDSHIFT&#39;])
                            kwargs_source_list.append(select_params(sim_dict, prefix + &#39;LIGHT_PROFILE_{0}-&#39;.format(light_profile_num)))
                        
                    else:
                        # Should never get here
                        assert False

            # Make image
            sim = SimAPI(numpix=sim_dict[&#39;numPix&#39;], 
                         kwargs_single_band=kwargs_single_band, 
                         kwargs_model=kwargs_model)

            imSim = sim.image_model_class(kwargs_numerics)
            
            kwargs_lens_light_list, kwargs_source_list, kwargs_point_source_list = sim.magnitude2amplitude(kwargs_lens_light_mag=kwargs_lens_light_list,
                                                                                                           kwargs_source_mag=kwargs_source_list,
                                                                                                           kwargs_ps_mag=kwargs_point_source_list)
            
            kwargs_lens_model_list = sim.physical2lensing_conversion(kwargs_mass=kwargs_lens_model_list)
            # Save theta_E (and sigma_v if used)
            for ii in range(len(output_metadata)):
                output_metadata.append({&#39;PARAM_NAME&#39;: output_metadata[ii][&#39;PARAM_NAME&#39;].replace(&#39;sigma_v&#39;, &#39;theta_E&#39;),
                                        &#39;PARAM_VALUE&#39;: kwargs_lens_model_list[output_metadata[ii][&#39;LENS_MODEL_IDX&#39;]][&#39;theta_E&#39;],
                                        &#39;LENS_MODEL_IDX&#39;: output_metadata[ii][&#39;LENS_MODEL_IDX&#39;]})
                
            try:
                image = imSim.image(kwargs_lens=kwargs_lens_model_list,
                                    kwargs_lens_light=kwargs_lens_light_list,
                                    kwargs_source=kwargs_source_list,
                                    kwargs_ps=kwargs_point_source_list)
            except Exception:
                # Some sort of lenstronomy error
                print(&#34;kwargs_numerics&#34;, kwargs_numerics)
                print(&#34;kwargs_single_band&#34;, kwargs_single_band)
                print(&#34;kwargs_model&#34;, kwargs_model)
                print(&#34;kwargs_lens_model_list&#34;, kwargs_lens_model_list)
                print(&#34;kwargs_lens_light_list&#34;, kwargs_lens_light_list)
                print(&#34;kwargs_source_list&#34;, kwargs_source_list)
                print(&#34;kwargs_point_source_list&#34;, kwargs_point_source_list)
                assert False
                                
            # Solve lens equation if desired
            if self.solve_lens_equation:
                solver = lens_equation_solver.LensEquationSolver(imSim.LensModel)
                x_mins, y_mins = solver.image_position_from_source(sourcePos_x=kwargs_source_list[0][&#39;center_x&#39;],
                                                                   sourcePos_y=kwargs_source_list[0][&#39;center_y&#39;],
                                                                   kwargs_lens=kwargs_lens_model_list)
                num_source_images = len(x_mins)
            
            # Add noise
            image_noise = np.zeros(np.shape(image))
            for noise_source_num in range(1, sim_dict[&#39;NUMBER_OF_NOISE_SOURCES&#39;] + 1):
                image_noise += self._generate_noise(sim_dict[&#39;NOISE_SOURCE_{0}-NAME&#39;.format(noise_source_num)],
                                                    np.shape(image),
                                                    select_params(sim_dict, &#39;NOISE_SOURCE_{0}-&#39;.format(noise_source_num)))
            image += image_noise
                
            # Combine with other bands
            output_image.append(image)

            # Store plane-separated info if requested
            if self.return_planes:
                output_lens.append(imSim.lens_surface_brightness(kwargs_lens_light_list))
                output_source.append(imSim.source_surface_brightness(kwargs_source_list, kwargs_lens_model_list))
                output_point_source.append(imSim.point_source(kwargs_point_source_list, kwargs_lens_model_list))
                output_noise.append(image_noise)
        
        # Return the desired information in a dictionary
        return_dict = {&#39;output_image&#39;: np.array(output_image),
                       &#39;output_lens_plane&#39;: None,
                       &#39;output_source_plane&#39;: None,
                       &#39;output_point_source_plane&#39;: None,
                       &#39;output_noise_plane&#39;: None,
                       &#39;x_mins&#39;: None,
                       &#39;y_mins&#39;: None,
                       &#39;num_source_images&#39;: None,
                       &#39;additional_metadata&#39;: output_metadata}
        if self.return_planes:
            return_dict[&#39;output_lens_plane&#39;] = np.array(output_lens)
            return_dict[&#39;output_source_plane&#39;] = np.array(output_source)
            return_dict[&#39;output_point_source_plane&#39;] = np.array(output_point_source)
            return_dict[&#39;output_noise_plane&#39;] = np.array(output_noise)
        if self.solve_lens_equation:
            return_dict[&#39;x_mins&#39;] = x_mins
            return_dict[&#39;y_mins&#39;] = y_mins
            return_dict[&#39;num_source_images&#39;] = num_source_images

        return return_dict

    def _generate_noise(self, name, shape, params):
        &#34;&#34;&#34;
        Add noise to image based on input yaml by targeting specified distribution.
        
        :param name: name of the distribution to target
        :param shape: shape of image to add noise to
        :param params: dictionary of additional parameters needed by distributions.name()
        :return: noise_image: noise from targeted distribution for the image
        &#34;&#34;&#34;
        return eval(&#39;distributions.{0}(shape, **params)&#39;.format(name.lower()))</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="deeplenstronomy.image_generator.ImageGenerator.sim_image"><code class="name flex">
<span>def <span class="ident">sim_image</span></span>(<span>self, info_dict)</span>
</code></dt>
<dd>
<div class="desc"><p>Simulate an image based on specifications in sim_dict</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>info_dict</code></strong> :&ensp;<code>dict</code></dt>
<dd>A single element from the list produced interanlly by input_reader.Organizer.breakup().
Contains all the properties of a single image to generate.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sim_image(self, info_dict):
    &#34;&#34;&#34;
    Simulate an image based on specifications in sim_dict
    
    Args:
        info_dict (dict): A single element from the list produced interanlly by input_reader.Organizer.breakup(). 
            Contains all the properties of a single image to generate.
    &#34;&#34;&#34;
    output_image = []
    if self.return_planes:
        output_source, output_lens, output_point_source, output_noise = [], [], [], []
    output_metadata = []
    
    #set the cosmology
    cosmology_info = [&#39;H0&#39;, &#39;Om0&#39;, &#39;Tcmb0&#39;, &#39;Neff&#39;, &#39;m_nu&#39;, &#39;Ob0&#39;]
    cosmo = FlatLambdaCDM(**dict_select_choose(list(info_dict.values())[0], cosmology_info))
    
    for band, sim_dict in info_dict.items():
        ### Geometry-independent image properties
        
        # Single Band Info
        single_band_info = [&#39;read_noise&#39;, &#39;pixel_scale&#39;, &#39;ccd_gain&#39;, &#39;exposure_time&#39;,
                            &#39;sky_brightness&#39;, &#39;seeing&#39;, &#39;magnitude_zero_point&#39;,
                            &#39;num_exposures&#39;, &#39;data_count_unit&#39;, &#39;background_noise&#39;]
        kwargs_single_band = dict_select_choose(sim_dict, single_band_info)
        
        # Extinction
        extinction_class = None  #figure this out later
        
        # Numerics -- only use single number kwargs
        numerics_info = [&#39;supersampling_factor&#39;, &#39;compute_mode&#39;, &#39;supersampling_convolution&#39;,
                         &#39;supersampling_kernel_size&#39;, &#39;point_source_supersampling_factor&#39;, 
                         &#39;convolution_kernel_size&#39;]
        kwargs_numerics = dict_select_choose(sim_dict, numerics_info)
        
        ### Geometry-dependent image properties
        
        # Dictionary for physical model
        kwargs_model = {&#39;lens_model_list&#39;: [],  # list of lens models to be used
                        &#39;lens_redshift_list&#39;: [],  # list of redshift of the deflections
                        &#39;lens_light_model_list&#39;: [],  # list of unlensed light models to be used
                        &#39;source_light_model_list&#39;: [],  # list of extended source models to be used
                        &#39;source_redshift_list&#39;: [],  # list of redshfits of the sources in same order as source_light_model_list
                        &#39;point_source_model_list&#39;: [], # list of point source models
                        &#39;cosmo&#39;: cosmo,
                        &#39;z_source&#39;: 0.0}

        # Lists for model kwargs
        kwargs_source_list, kwargs_lens_model_list, kwargs_lens_light_list, kwargs_point_source_list = [], [], [], []
        
        for plane_num in range(1, sim_dict[&#39;NUMBER_OF_PLANES&#39;] + 1):
            
            for obj_num in range(1, sim_dict[&#39;PLANE_{0}-NUMBER_OF_OBJECTS&#39;.format(plane_num)] + 1):
                
                prefix = &#39;PLANE_{0}-OBJECT_{1}-&#39;.format(plane_num, obj_num)
                
                ### Point sources
                if sim_dict[prefix + &#39;HOST&#39;] != &#39;None&#39;:
                    
                    # Foreground objects
                    if sim_dict[prefix + &#39;HOST&#39;] == &#39;Foreground&#39;:
                        kwargs_model[&#39;point_source_model_list&#39;].append(&#39;UNLENSED&#39;)
                        ps_info = [&#39;PLANE_{0}-OBJECT_{1}-{2}&#39;.format(plane_num, obj_num, x) for x in [&#39;ra_image&#39;, &#39;dec_image&#39;, &#39;magnitude&#39;]]
                        ps_dict_info = dict_select(sim_dict, ps_info)
                        kwargs_point_source_list.append({&#39;ra_image&#39;: [ps_dict_info[prefix + &#39;ra_image&#39;]], &#39;dec_image&#39;: [ps_dict_info[prefix + &#39;dec_image&#39;]], &#39;magnitude&#39;: [ps_dict_info[prefix + &#39;magnitude&#39;]]})
                    # Real point sources
                    else:
                        if plane_num &lt; sim_dict[&#39;NUMBER_OF_PLANES&#39;]:
                            # point sources in the lens
                            kwargs_model[&#39;point_source_model_list&#39;].append(&#39;LENSED_POSITION&#39;)
                            ps_info = [&#39;PLANE_{0}-OBJECT_{1}-{2}&#39;.format(plane_num, obj_num, x) for x in [&#39;ra&#39;, &#39;dec&#39;, &#39;magnitude&#39;]]
                            ps_dict_info = dict_select(sim_dict, ps_info)
                            kwargs_point_source_list.append({&#39;ra_image&#39;: [ps_dict_info[prefix + &#39;ra&#39;]],
                                                             &#39;dec_image&#39;: [ps_dict_info[prefix + &#39;dec&#39;]],
                                                             &#39;magnitude&#39;: [ps_dict_info[prefix + &#39;magnitude&#39;]]})
                        elif plane_num == sim_dict[&#39;NUMBER_OF_PLANES&#39;]:
                            # point sources in the source plane
                            kwargs_model[&#39;point_source_model_list&#39;].append(&#39;SOURCE_POSITION&#39;)
                            ps_info = [&#39;PLANE_{0}-OBJECT_{1}-{2}&#39;.format(plane_num, obj_num, x) for x in [&#39;ra&#39;, &#39;dec&#39;, &#39;magnitude&#39;]]
                            ps_dict_info = dict_select(sim_dict, ps_info)
                            kwargs_point_source_list.append({&#39;ra_source&#39;: ps_dict_info[&#39;PLANE_{0}-OBJECT_{1}-ra&#39;.format(plane_num, obj_num)], 
                                                             &#39;dec_source&#39;: ps_dict_info[&#39;PLANE_{0}-OBJECT_{1}-dec&#39;.format(plane_num, obj_num)], 
                                                             &#39;magnitude&#39;: ps_dict_info[&#39;PLANE_{0}-OBJECT_{1}-magnitude&#39;.format(plane_num, obj_num)]})
                        else:
                            #should never get here
                            assert False
                            
                    # the number of profiles will be zero for point sources, so just skip ahead
                    continue
                
                ### Model keywords
                # All planes except last one - treat as lens
                if plane_num &lt; sim_dict[&#39;NUMBER_OF_PLANES&#39;]:
                    for light_profile_num in range(1, sim_dict[prefix + &#39;NUMBER_OF_LIGHT_PROFILES&#39;] +1):
                        kwargs_model[&#39;lens_light_model_list&#39;].append(sim_dict[prefix + &#39;LIGHT_PROFILE_{0}-NAME&#39;.format(light_profile_num)])
                        #kwargs_model[&#39;lens_redshift_list&#39;].append(sim_dict[prefix + &#39;REDSHIFT&#39;])
                        kwargs_lens_light_list.append(select_params(sim_dict, prefix + &#39;LIGHT_PROFILE_{0}-&#39;.format(light_profile_num)))
                    for mass_profile_num in range(1, sim_dict[prefix + &#39;NUMBER_OF_MASS_PROFILES&#39;] +1):
                        kwargs_model[&#39;lens_model_list&#39;].append(sim_dict[prefix + &#39;MASS_PROFILE_{0}-NAME&#39;.format(mass_profile_num)])
                        kwargs_model[&#39;lens_redshift_list&#39;].append(sim_dict[prefix + &#39;REDSHIFT&#39;])
                        mass_params = select_params(sim_dict, prefix + &#39;MASS_PROFILE_{0}-&#39;.format(mass_profile_num))
                        kwargs_lens_model_list.append(mass_params)
                        if &#39;sigma_v&#39; in mass_params.keys(): # save simga_v locations so that we can calculate theta_E for the metadata
                            output_metadata.append({&#39;PARAM_NAME&#39;:  prefix + &#39;MASS_PROFILE_{0}-sigma_v-{1}&#39;.format(mass_profile_num, band),
                                                    &#39;PARAM_VALUE&#39;: mass_params[&#39;sigma_v&#39;],
                                                    &#39;LENS_MODEL_IDX&#39;: len(kwargs_lens_model_list) - 1})
                    for shear_profile_num in range(1, sim_dict[prefix + &#39;NUMBER_OF_SHEAR_PROFILES&#39;] +1):
                        kwargs_model[&#39;lens_model_list&#39;].append(sim_dict[prefix + &#39;SHEAR_PROFILE_{0}-NAME&#39;.format(shear_profile_num)])
                        kwargs_model[&#39;lens_redshift_list&#39;].append(sim_dict[prefix + &#39;REDSHIFT&#39;])
                        mass_params = select_params(sim_dict, prefix + &#39;SHEAR_PROFILE_{0}-&#39;.format(shear_profile_num))
                        kwargs_lens_model_list.append(select_params(sim_dict, prefix + &#39;SHEAR_PROFILE_{0}-&#39;.format(shear_profile_num)))
                                               
                # Last Plane - treat as source
                elif plane_num == sim_dict[&#39;NUMBER_OF_PLANES&#39;]:
                    kwargs_model[&#39;z_source&#39;] = sim_dict[prefix + &#39;REDSHIFT&#39;]
                    for light_profile_num in range(1, sim_dict[prefix + &#39;NUMBER_OF_LIGHT_PROFILES&#39;] +1):
                        kwargs_model[&#39;source_light_model_list&#39;].append(sim_dict[prefix + &#39;LIGHT_PROFILE_{0}-NAME&#39;.format(light_profile_num)])
                        kwargs_model[&#39;source_redshift_list&#39;].append(sim_dict[prefix + &#39;REDSHIFT&#39;])
                        kwargs_source_list.append(select_params(sim_dict, prefix + &#39;LIGHT_PROFILE_{0}-&#39;.format(light_profile_num)))
                    
                else:
                    # Should never get here
                    assert False

        # Make image
        sim = SimAPI(numpix=sim_dict[&#39;numPix&#39;], 
                     kwargs_single_band=kwargs_single_band, 
                     kwargs_model=kwargs_model)

        imSim = sim.image_model_class(kwargs_numerics)
        
        kwargs_lens_light_list, kwargs_source_list, kwargs_point_source_list = sim.magnitude2amplitude(kwargs_lens_light_mag=kwargs_lens_light_list,
                                                                                                       kwargs_source_mag=kwargs_source_list,
                                                                                                       kwargs_ps_mag=kwargs_point_source_list)
        
        kwargs_lens_model_list = sim.physical2lensing_conversion(kwargs_mass=kwargs_lens_model_list)
        # Save theta_E (and sigma_v if used)
        for ii in range(len(output_metadata)):
            output_metadata.append({&#39;PARAM_NAME&#39;: output_metadata[ii][&#39;PARAM_NAME&#39;].replace(&#39;sigma_v&#39;, &#39;theta_E&#39;),
                                    &#39;PARAM_VALUE&#39;: kwargs_lens_model_list[output_metadata[ii][&#39;LENS_MODEL_IDX&#39;]][&#39;theta_E&#39;],
                                    &#39;LENS_MODEL_IDX&#39;: output_metadata[ii][&#39;LENS_MODEL_IDX&#39;]})
            
        try:
            image = imSim.image(kwargs_lens=kwargs_lens_model_list,
                                kwargs_lens_light=kwargs_lens_light_list,
                                kwargs_source=kwargs_source_list,
                                kwargs_ps=kwargs_point_source_list)
        except Exception:
            # Some sort of lenstronomy error
            print(&#34;kwargs_numerics&#34;, kwargs_numerics)
            print(&#34;kwargs_single_band&#34;, kwargs_single_band)
            print(&#34;kwargs_model&#34;, kwargs_model)
            print(&#34;kwargs_lens_model_list&#34;, kwargs_lens_model_list)
            print(&#34;kwargs_lens_light_list&#34;, kwargs_lens_light_list)
            print(&#34;kwargs_source_list&#34;, kwargs_source_list)
            print(&#34;kwargs_point_source_list&#34;, kwargs_point_source_list)
            assert False
                            
        # Solve lens equation if desired
        if self.solve_lens_equation:
            solver = lens_equation_solver.LensEquationSolver(imSim.LensModel)
            x_mins, y_mins = solver.image_position_from_source(sourcePos_x=kwargs_source_list[0][&#39;center_x&#39;],
                                                               sourcePos_y=kwargs_source_list[0][&#39;center_y&#39;],
                                                               kwargs_lens=kwargs_lens_model_list)
            num_source_images = len(x_mins)
        
        # Add noise
        image_noise = np.zeros(np.shape(image))
        for noise_source_num in range(1, sim_dict[&#39;NUMBER_OF_NOISE_SOURCES&#39;] + 1):
            image_noise += self._generate_noise(sim_dict[&#39;NOISE_SOURCE_{0}-NAME&#39;.format(noise_source_num)],
                                                np.shape(image),
                                                select_params(sim_dict, &#39;NOISE_SOURCE_{0}-&#39;.format(noise_source_num)))
        image += image_noise
            
        # Combine with other bands
        output_image.append(image)

        # Store plane-separated info if requested
        if self.return_planes:
            output_lens.append(imSim.lens_surface_brightness(kwargs_lens_light_list))
            output_source.append(imSim.source_surface_brightness(kwargs_source_list, kwargs_lens_model_list))
            output_point_source.append(imSim.point_source(kwargs_point_source_list, kwargs_lens_model_list))
            output_noise.append(image_noise)
    
    # Return the desired information in a dictionary
    return_dict = {&#39;output_image&#39;: np.array(output_image),
                   &#39;output_lens_plane&#39;: None,
                   &#39;output_source_plane&#39;: None,
                   &#39;output_point_source_plane&#39;: None,
                   &#39;output_noise_plane&#39;: None,
                   &#39;x_mins&#39;: None,
                   &#39;y_mins&#39;: None,
                   &#39;num_source_images&#39;: None,
                   &#39;additional_metadata&#39;: output_metadata}
    if self.return_planes:
        return_dict[&#39;output_lens_plane&#39;] = np.array(output_lens)
        return_dict[&#39;output_source_plane&#39;] = np.array(output_source)
        return_dict[&#39;output_point_source_plane&#39;] = np.array(output_point_source)
        return_dict[&#39;output_noise_plane&#39;] = np.array(output_noise)
    if self.solve_lens_equation:
        return_dict[&#39;x_mins&#39;] = x_mins
        return_dict[&#39;y_mins&#39;] = y_mins
        return_dict[&#39;num_source_images&#39;] = num_source_images

    return return_dict</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="deeplenstronomy" href="index.html">deeplenstronomy</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="deeplenstronomy.image_generator.ImageGenerator" href="#deeplenstronomy.image_generator.ImageGenerator">ImageGenerator</a></code></h4>
<ul class="">
<li><code><a title="deeplenstronomy.image_generator.ImageGenerator.sim_image" href="#deeplenstronomy.image_generator.ImageGenerator.sim_image">sim_image</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>