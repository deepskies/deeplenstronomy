<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>deeplenstronomy.timeseries API documentation</title>
<meta name="description" content="Generate light curves from time-series spectral energy distributions" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>deeplenstronomy.timeseries</code></h1>
</header>
<section id="section-intro">
<p>Generate light curves from time-series spectral energy distributions</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Generate light curves from time-series spectral energy distributions&#34;&#34;&#34;

import glob
import os
import random
import warnings
warnings.filterwarnings(&#34;ignore&#34;)

from astropy.cosmology import FlatLambdaCDM
import astropy.units as u
import numpy as np
import pandas as pd
from scipy.interpolate import interp1d
from scipy.integrate import quad

class LCGen():
    &#34;&#34;&#34;Light Curve Generation&#34;&#34;&#34;    
    def __init__(self, bands=&#39;&#39;):
        &#34;&#34;&#34;
        Initialize the LCGen object, download data if necessary, collect 
        necessary filter and sed information.
        
        Args:
            bands (str): comma-separated string of bands, i.e. &#39;g,r,i,z&#39;
        &#34;&#34;&#34;
        # Check for filtes / seds and download if necessary
        self.__download_data()
        
        # Collect sed files
        self.ia_sed_files = glob.glob(&#39;seds/ia/*.dat&#39;)
        self.cc_sed_files = glob.glob(&#39;seds/cc/*.SED&#39;)
        self.__read_cc_weights()
        
        # Collect filter transmission curves
        self.filter_files = glob.glob(&#39;filters/*.dat&#39;)
        self.bands = bands.split(&#39;,&#39;)
        
        # Interpolate the transmission curves
        for band in self.bands:
            transmission_frequency, transmission_wavelength = self.__read_passband(band)
            setattr(self, &#39;{0}_transmission_frequency&#39;.format(band), transmission_frequency)
            setattr(self, &#39;{0}_transmission_wavelength&#39;.format(band), transmission_wavelength)
        
        return

    def __download_data(self):
        &#34;&#34;&#34;
        Check for required data and download if it is missing
        &#34;&#34;&#34;
        if not os.path.exists(&#39;seds&#39;):
            os.mkdir(&#39;seds&#39;)
        if not os.path.exists(&#39;seds/ia&#39;):
            os.system(&#39;svn checkout https://github.com/rmorgan10/deeplenstronomy_data/trunk/seds/ia&#39;)
            os.system(&#39;mv ia seds&#39;)
        if not os.path.exists(&#39;seds/cc&#39;):
            os.system(&#39;svn checkout https://github.com/rmorgan10/deeplenstronomy_data/trunk/seds/cc&#39;)
            os.system(&#39;mv cc seds&#39;)
        if not os.path.exists(&#39;seds/kn&#39;):
            os.system(&#39;svn checkout https://github.com/rmorgan10/deeplenstronomy_data/trunk/seds/kn&#39;)
            os.system(&#39;mv kn seds&#39;)
        if not os.path.exists(&#39;filters&#39;):
            os.system(&#39;svn checkout https://github.com/rmorgan10/deeplenstronomy_data/trunk/filters&#39;)
    
    def __read_cc_weights(self):
        &#34;&#34;&#34;
        Read Core-Collapse SNe metadata
        
        :assign cc_info_df: dataframe containing all CC template metadata
        :assign cc_weights: lists of weights for each template
        &#34;&#34;&#34;
        df = pd.read_csv(&#39;seds/cc/SIMGEN_INCLUDE_NON1A.INPUT&#39;, comment=&#39;#&#39;, delim_whitespace=True)
        self.cc_info_df = df
        self.cc_weights = [df[&#39;WGT&#39;].values[df[&#39;SED&#39;].values == x.split(&#39;/&#39;)[-1].split(&#39;.&#39;)[0]][0] for x in self.cc_sed_files]
        return
        
    
    def __read_passband(self, band):
        &#34;&#34;&#34;
        Read and interolate filter transmission curves
        
        :param band: the single-letter band identifier
        :return: transmisison_frequency: interpolated filter transmission as a function of frequency
        :return: transmisison_wavelength: interpolated filter transmission as a function of wavelength
        &#34;&#34;&#34;
        #Target filter file associated with band
        filter_file = [x for x in self.filter_files if x.find(&#39;_&#39; + band) != -1][0]
        
        # Read and format filter transmission info
        passband = pd.read_csv(filter_file, 
                               names=[&#39;WAVELENGTH&#39;, &#39;TRANSMISSION&#39;], 
                               delim_whitespace=True, comment=&#39;#&#39;)
        setattr(self, &#39;_{0}_obs_frame_freq_min&#39;.format(band), 2.99792458e18 / np.max(passband[&#39;WAVELENGTH&#39;].values))
        setattr(self, &#39;_{0}_obs_frame_freq_max&#39;.format(band), 2.99792458e18 / np.min(passband[&#39;WAVELENGTH&#39;].values))
        
        # Add boundary terms to cover the whole range
        passband.loc[passband.shape[0]] = (1.e-1, 0.0)
        passband.loc[passband.shape[0]] = (4.e+4, 0.0)
        
        # Convert to frequency using speed of light in angstroms
        passband[&#39;FREQUENCY&#39;] = 2.99792458e18 / passband[&#39;WAVELENGTH&#39;].values
        setattr(self, &#39;{0}_obs_frame_transmission&#39;.format(band), passband)
        
        # Interpolate and return
        transmission_frequency = interp1d(passband[&#39;FREQUENCY&#39;].values, passband[&#39;TRANSMISSION&#39;].values, fill_value=0.0)
        transmission_wavelength = interp1d(passband[&#39;WAVELENGTH&#39;].values, passband[&#39;TRANSMISSION&#39;].values, fill_value=0.0)
        return transmission_frequency, transmission_wavelength

    
    def _read_sed(self, sed_filename):
        &#34;&#34;&#34;
        Read a Spectral Enerrgy Distribution into a dataframe
        
        :param sed_filename: name of file describing the sed
        :return: sed: a dataframe of the sed
        &#34;&#34;&#34;
        
        # Read and format sed info
        sed = pd.read_csv(sed_filename,
                          names=[&#39;NITE&#39;, &#39;WAVELENGTH_REST&#39;, &#39;FLUX&#39;], 
                          delim_whitespace=True, comment=&#39;#&#39;)
        for nite in np.unique(sed[&#39;NITE&#39;].values):
            sed.loc[sed.shape[0]] = (nite, 10.0, 0.0)
            sed.loc[sed.shape[0]] = (nite, 25000.0, 0.0)
        sed[&#39;FREQUENCY_REST&#39;] = 2.99792458e18 / sed[&#39;WAVELENGTH_REST&#39;].values
        
        # Normalize
        func = interp1d(sed[&#39;WAVELENGTH_REST&#39;].values, sed[&#39;FLUX&#39;].values)
        sed[&#39;FLUX&#39;] = sed[&#39;FLUX&#39;].values / quad(func, 10.0, 25000.0)[0]
        
        # Round nights to nearest int
        sed[&#39;NITE&#39;] = [round(x) for x in sed[&#39;NITE&#39;].values]
        
        return sed
    
    def _get_kcorrect(self, sed, band, redshift):
        &#34;&#34;&#34;
        Calculate the K-Correction
        
        :param sed: the sed on the night of peak flux
        :param band: the single-letter band being used
        :param redshift: the redshift of the object
        :return: kcor: the k-correction to the absolute magnitude
        &#34;&#34;&#34;
        return -2.5 * np.log10((1.0 + redshift) * 
                               (self._integrate_through_band(sed, band, redshift, frame=&#39;OBS&#39;) /
                                self._integrate_through_band(sed, band, redshift, frame=&#39;REST&#39;)))
        
    def _get_distance_modulus(self, redshift, cosmo):
        &#34;&#34;&#34;
        Calculate the dimming effect of distance to the source
        
        :param redshift: the redshift of the object
        :param cosmo: an astropy.cosmology instance
        :return: dmod: the distance modulus contribution to the apparent magnitude
        &#34;&#34;&#34;
        return 5.0 * np.log10(cosmo.luminosity_distance(redshift).value * 10 ** 6 / 10)

    
    def _integrate_through_band(self, sed, band, redshift, frame=&#39;REST&#39;):
        &#34;&#34;&#34;
        Calculate the flux through a given band by integrating in frequency
        
        :param sed: a dataframe containing the sed of the object
        :param band: the single-letter filter being used
        :param redshift: the redshift of the source
        :param frame: chose from [&#39;REST&#39;, &#39;OBS&#39;] to choose the rest frame or the observer frame
        :return: flux: the measured flux from the source through the filter
        &#34;&#34;&#34;
        # Tighten bounds for accurate integration
        lower_bound = eval(&#39;self._{0}_obs_frame_freq_min&#39;.format(band))
        upper_bound = eval(&#39;self._{0}_obs_frame_freq_max&#39;.format(band))        
        frequency_arr = np.linspace(lower_bound, upper_bound, 100000)
        
        # Make an interpolated version of the integrand
        interpolated_sed = interp1d(sed[&#39;FREQUENCY_{0}&#39;.format(frame)].values, sed[&#39;FLUX&#39;].values, fill_value=0.0)
        integrand = eval(&#39;self.{0}_transmission_frequency(frequency_arr) * interpolated_sed(frequency_arr) / frequency_arr&#39;.format(band))
        interpolated_integrand = interp1d(frequency_arr, integrand, fill_value=0.0)
               
        # Integrate and return
        return quad(interpolated_integrand, lower_bound, upper_bound, limit=500)[0]
    
    def _get_closest_nite(self, unique_nites, nite):
        &#34;&#34;&#34;
        Return the nite in the sed closest to a desired nite
        
        :param unique_nites: a set of the nights in an sed
        :param nite: the nite you wish to find the closest neighbor for
        :return: closest_nite: the closest nite in the sed to the given nite
        &#34;&#34;&#34;
        return unique_nites[np.argmin(np.abs(nite - unique_nites))]

    def gen_variable(self, redshift, nites, sed=None, sed_filename=None, cosmo=None):
        &#34;&#34;&#34;
        Generate a random variable light curve

        Args:
            redshift (float): ignored 
            nites (List[int]): a list of night relative to peak you want to obtain a magnitude for    
            sed_filename (str): ignored
            cosmo (astropy.cosmology): ignored

        Returns:
            lc_dict: a dictionary with keys [&#39;lc, &#39;obj_type&#39;, &#39;sed&#39;]
              - &#39;lc&#39; contains a dataframe of the light from the object     
              - &#39;obj_type&#39; contains a string for the type of object. Will always be &#39;Variable&#39; here
              - &#39;sed&#39; contains the filename of the sed used. Will always be &#39;Variable&#39; here  
        &#34;&#34;&#34;
        output_data_cols = [&#39;NITE&#39;, &#39;BAND&#39;, &#39;MAG&#39;]
        output_data = []
        central_mag = random.uniform(12.0, 23.0)
        colors = {band: mag for band, mag in zip(self.bands, np.random.uniform(low=-2.0, high=2.0, size=len(self.bands)))}
        for nite in nites:
            central_mag = random.uniform(central_mag - 1.0, central_mag + 1.0)
            for band in self.bands:
                output_data.append([nite, band, central_mag + colors[band]])

        return {&#39;lc&#39;: pd.DataFrame(data=output_data, columns=output_data_cols),
                &#39;obj_type&#39;: &#39;Variable&#39;,
                &#39;sed&#39;: &#39;Variable&#39;}
    
    def gen_flat(self, redshift, nites, sed=None, sed_filename=None, cosmo=None):
        &#34;&#34;&#34;
        Generate a random flat light curve.
        
        Args:
            redshift (float): ignored
            nites (List[int]): a list of night relative to peak you want to obtain a magnitude for
            sed_filename (str): ignored
            cosmo (astropy.cosmology): ignored

        Returns:
            lc_dict: a dictionary with keys [&#39;lc, &#39;obj_type&#39;, &#39;sed&#39;]
              - &#39;lc&#39; contains a dataframe of the light from the object
              - &#39;obj_type&#39; contains a string for the type of object. Will always be &#39;Flat&#39; here
              - &#39;sed&#39; contains the filename of the sed used. Will always be &#39;Flat&#39; here      
        &#34;&#34;&#34;
        output_data_cols = [&#39;NITE&#39;, &#39;BAND&#39;, &#39;MAG&#39;]
        central_mag = random.uniform(12.0, 23.0)
        mags = {band: mag for band, mag in zip(self.bands, central_mag + np.random.uniform(low=-2.0, high=2.0, size=len(self.bands)))}
        output_data = []
        for nite in nites:
            for band in self.bands:
                output_data.append([nite, band, mags[band]])

        return {&#39;lc&#39;: pd.DataFrame(data=output_data, columns=output_data_cols),
                &#39;obj_type&#39;: &#39;Flat&#39;,
                &#39;sed&#39;: &#39;Flat&#39;}

    def gen_static(self, redshift, nites, sed=None, sed_filename=None, cosmo=None):
        &#34;&#34;&#34;
        Make a static source capable of having time-series data by introducing a mag=99 source
        on each NITE of the simulation.

        Args:
            redshift (float): ignored 
            nites (List[int]): a list of night relative to peak you want to obtain a magnitude for
            sed_filename (str): ignored                                                                                                                                                               
            cosmo (astropy.cosmology): ignored                                                                                                                                                                                            
        Returns:
            lc_dict: a dictionary with keys [&#39;lc, &#39;obj_type&#39;, &#39;sed&#39;]
              - &#39;lc&#39; contains a dataframe of the light from the object
              - &#39;obj_type&#39; contains a string for the type of object. Will always be &#39;Static&#39; here
              - &#39;sed&#39; contains the filename of the sed used. Will always be &#39;Flat&#39; here                                                                                                                        &#34;&#34;&#34;
        output_data_cols = [&#39;NITE&#39;, &#39;BAND&#39;, &#39;MAG&#39;]
        central_mag = 99.0
        mags = {band: central_mag for band in self.bands}
        output_data = []
        for nite in nites:
            for band in self.bands:
                output_data.append([nite, band, mags[band]])

        return {&#39;lc&#39;: pd.DataFrame(data=output_data, columns=output_data_cols),
                &#39;obj_type&#39;: &#39;Static&#39;,
                &#39;sed&#39;: &#39;Static&#39;}


        
    def gen_variablenoise(self, redshift, nites, sed=None, sed_filename=None, cosmo=None):
        &#34;&#34;&#34; 
        Generate a variable light curve with small random noise

        Args:
            redshift (float): ignored
            nites (List[int]): a list of night relative to peak you want to obtain a magnitude for
            sed_filename (str): ignored
            cosmo (astropy.cosmology): ignored

        Returns:
            lc_dict: a dictionary with keys [&#39;lc, &#39;obj_type&#39;, &#39;sed&#39;]
              - &#39;lc&#39; contains a dataframe of the light from the object
              - &#39;obj_type&#39; contains a string for the type of object. Will always be &#39;VariableNoise&#39; here
              - &#39;sed&#39; contains the filename of the sed used. Will always be &#39;VariableNoise&#39; here              
        &#34;&#34;&#34;
        noiseless_lc_dict = self.gen_variable(redshift, nites)
        noise = np.random.normal(loc=0, scale=0.25, size=noiseless_lc_dict[&#39;lc&#39;].shape[0])
        noiseless_lc_dict[&#39;lc&#39;][&#39;MAG&#39;] = noiseless_lc_dict[&#39;lc&#39;][&#39;MAG&#39;].values + noise
        noiseless_lc_dict[&#39;obj_type&#39;] = &#39;VariableNoise&#39;
        noiseless_lc_dict[&#39;sed&#39;] = &#39;VariableNoise&#39;
        return noiseless_lc_dict

    
    def gen_flatnoise(self, redshift, nites, sed=None, sed_filename=None, cosmo=None):
        &#34;&#34;&#34;
        Generate a flat light curve will small random noise

        Args:
            redshift (float): ignored
            nites (List[int]): a list of night relative to peak you want to obtain a magnitude for
            sed_filename (str): ignored
            cosmo (astropy.cosmology): ignored

        Returns:
            lc_dict: a dictionary with keys [&#39;lc, &#39;obj_type&#39;, &#39;sed&#39;]
              - &#39;lc&#39; contains a dataframe of the light from the object
              - &#39;obj_type&#39; contains a string for the type of object. Will always be &#39;FlatNoise&#39; here
              - &#39;sed&#39; contains the filename of the sed used. Will always be &#39;FlatNoise&#39; here              
        &#34;&#34;&#34;
        noiseless_lc_dict = self.gen_flat(redshift, nites)
        noise = np.random.normal(loc=0, scale=0.25, size=noiseless_lc_dict[&#39;lc&#39;].shape[0])
        noiseless_lc_dict[&#39;lc&#39;][&#39;MAG&#39;] = noiseless_lc_dict[&#39;lc&#39;][&#39;MAG&#39;].values + noise
        noiseless_lc_dict[&#39;obj_type&#39;] = &#39;FlatNoise&#39;
        noiseless_lc_dict[&#39;sed&#39;] = &#39;FlatNoise&#39;
        return noiseless_lc_dict
        
    def gen_user(self, redshift, nites, sed=None, sed_filename=None, cosmo=None):
        &#34;&#34;&#34;
        Generate a light curve from a user-specidied SED

        Args:
            redshift (float): the redshift of the source
            nites (List[int]): a list of night relative to peak you want to obtain a magnitude for 
            sed (None or pandas.DataFrame, optional, default=None): a dataframe containing the sed of the SN 
            sed_filename (str): filename containing the time-series sed you want to use 
            cosmo (astropy.cosmology): an astropy.cosmology instance used for distance calculations

        Returns:
            lc_dict: a dictionary with keys [&#39;lc, &#39;obj_type&#39;, &#39;sed&#39;]
              - &#39;lc&#39; contains a dataframe of the light from the object
              - &#39;obj_type&#39; contains a string for the type of object. Will always be &lt;sed_filename&gt; here 
              - &#39;sed&#39; contains the filename of the sed used  
        &#34;&#34;&#34;
        if not sed:
            sed = self._read_sed(&#39;seds/user/&#39; + sed_filename)

        return self.gen_lc_from_sed(redshift, nites, sed, sed_filename, sed_filename, cosmo=cosmo)

    def gen_kn(self, redshift, nites, sed=None, sed_filename=None, cosmo=None):
        &#34;&#34;&#34;
        Generate a GW170817-like light curve.

        Args:
            redshift (float): the redshift of the source
            nites (List[int]): a list of night relative to peak you want to obtain a magnitude for 
            sed (None or pandas.DataFrame, optional, default=None): a dataframe containing the sed of the SN 
            sed_filename (str): filename containing the time-series sed you want to use 
            cosmo (astropy.cosmology): an astropy.cosmology instance used for distance calculations

        Returns:
            lc_dict: a dictionary with keys [&#39;lc, &#39;obj_type&#39;, &#39;sed&#39;]
              - &#39;lc&#39; contains a dataframe of the light from the object
              - &#39;obj_type&#39; contains a string for the type of object. Will always be KN here 
              - &#39;sed&#39; contains the filename of the sed used  
        &#34;&#34;&#34;

        sed_filename = &#39;seds/kn/kn.SED&#39;
        if not sed:
            sed = self._read_sed(sed_filename)

        return self.gen_lc_from_sed(redshift, nites, sed, &#39;KN&#39;, sed_filename, cosmo=cosmo)
    
    def gen_ia(self, redshift, nites, sed=None, sed_filename=None, cosmo=None):
        &#34;&#34;&#34;
        Generate a SN-Ia light curve.
        

        Args:
            redshift (float): the redshift of the source
            nites (List[int]): a list of night relative to peak you want to obtain a magnitude for 
            sed (None or pandas.DataFrame, optional, default=None): a dataframe containing the sed of the SN 
            sed_filename (str): filename containing the time-series sed you want to use 
            cosmo (astropy.cosmology): an astropy.cosmology instance used for distance calculations

        Returns:
            lc_dict: a dictionary with keys [&#39;lc, &#39;obj_type&#39;, &#39;sed&#39;]
              - &#39;lc&#39; contains a dataframe of the light from the object
              - &#39;obj_type&#39; contains a string for the type of object. Will always be Ia here 
              - &#39;sed&#39; contains the filename of the sed used  
        &#34;&#34;&#34;
        
        # Read rest-frame sed if not supplied as argument
        if not sed:
            if sed_filename:
                sed = self._read_sed(&#39;seds/ia/&#39; + sed_filename)
            else:
                sed_filename = random.choice(self.ia_sed_files)
                sed = self._read_sed(sed_filename)
                
        # Trigger the lc generation function on this sed
        return self.gen_lc_from_sed(redshift, nites, sed, &#39;Ia&#39;, sed_filename, cosmo=cosmo)
    
    def gen_cc(self, redshift, nites, sed=None, sed_filename=None, cosmo=None):
        &#34;&#34;&#34;
        Generate a SN-CC light curve
        
        Args:
            redshift (float): the redshift of the source
            nites (List[int]): a list of night relative to peak you want to obtain a magnitude for 
            sed (None or pandas.DataFrame, optional, default=None): a dataframe containing the sed of the SN 
            sed_filename (str): filename containing the time-series sed you want to use 
            cosmo (astropy.cosmology): an astropy.cosmology instance used for distance calculations

        Returns:
            lc_dict: a dictionary with keys [&#39;lc, &#39;obj_type&#39;, &#39;sed&#39;]
              - &#39;lc&#39; contains a dataframe of the light from the object
              - &#39;obj_type&#39; contains a string for the type of object. Will be &#39;II&#39;, &#39;Ibc, etc. 
              - &#39;sed&#39; contains the filename of the sed used  
        &#34;&#34;&#34;

        # If sed not specified, choose sed based on weight map
        if not sed:
            if sed_filename:
                sed = self._read_sed(&#39;seds/cc/&#39; + sed_filename)
            else:
                sed_filename = random.choices(self.cc_sed_files, weights=self.cc_weights, k=1)[0]
                sed = self._read_sed(sed_filename)
        
        # Get the type of SN-CC
        obj_type = self.cc_info_df[&#39;SNTYPE&#39;].values[self.cc_info_df[&#39;SED&#39;].values == sed_filename.split(&#39;/&#39;)[-1].split(&#39;.&#39;)[0]][0]
        
        # Trigger the lc generation function on this sed
        return self.gen_lc_from_sed(redshift, nites, sed, obj_type, sed_filename, cosmo=cosmo)
                
    def gen_lc_from_sed(self, redshift, nites, sed, obj_type, sed_filename, cosmo=None):
        &#34;&#34;&#34;
        Generate a light curve based on a time-series sed.
        
        Args:
            redshift (float): the redshift of the source
            nites (List[int]): a list of night relative to peak you want to obtain a magnitude for 
            sed (None or pandas.DataFrame, optional, default=None): a dataframe containing the sed of the SN 
            sed_filename (str): filename containing the time-series sed you want to use 
            cosmo (astropy.cosmology): an astropy.cosmology instance used for distance calculations

        Returns:
            lc_dict: a dictionary with keys [&#39;lc, &#39;obj_type&#39;, &#39;sed&#39;]
              - &#39;lc&#39; contains a dataframe of the light from the object
              - &#39;obj_type&#39; contains a string for the type of object. 
              - &#39;sed&#39; contains the filename of the sed used  
        &#34;&#34;&#34;
        
        # If nite not in the sed, set nite to the closest nite in the sed
        useable_nites = []
        sed_nites = np.unique(sed[&#39;NITE&#39;].values)
        for nite in nites:
            if nite not in sed_nites:
                useable_nites.append(self._get_closest_nite(sed_nites, nite))
            else:
                useable_nites.append(nite)
        nites = useable_nites
            
        # Redshift the sed frequencies and wavelengths
        sed[&#39;WAVELENGTH_OBS&#39;] = (1.0 + redshift) * sed[&#39;WAVELENGTH_REST&#39;].values
        sed[&#39;FREQUENCY_OBS&#39;] = sed[&#39;FREQUENCY_REST&#39;].values * (1.0 + redshift)
        
        # Calculate distance modulus
        if not cosmo:
            cosmo = FlatLambdaCDM(H0=69.3 * u.km / (u.Mpc * u.s), 
                                  Om0=0.286, Tcmb0=2.725 * u.K, Neff=3.04, Ob0=0.0463)
        distance_modulus = self._get_distance_modulus(redshift, cosmo=cosmo)
        
        # Calculate k-correction at peak
        peak_sed = sed[sed[&#39;NITE&#39;].values == self._get_closest_nite(np.unique(sed[&#39;NITE&#39;].values), 0)].copy().reset_index(drop=True)
        k_corrections = [self._get_kcorrect(peak_sed, band, redshift) for band in self.bands]
        
        # On each nite, in each band, calculate the absolute mag
        output_data = []
        output_data_cols = [&#39;NITE&#39;, &#39;BAND&#39;, &#39;MAG&#39;]
        for nite in nites:
            nite_sed = sed[sed[&#39;NITE&#39;].values == nite].copy().reset_index(drop=True)
            
            # Apply factors to calculate absolute mag
            nite_sed[&#39;FLUX&#39;] = (cosmo.luminosity_distance(redshift).value * 10 ** 6 / 10) ** 2 / (1 + redshift) * nite_sed[&#39;FLUX&#39;].values
            nite_sed[&#39;FREQUENCY_REST&#39;] = nite_sed[&#39;FREQUENCY_REST&#39;].values / (1. + redshift)
            
            # Convert to AB Magnitude system
            norm_sed = nite_sed.copy()
            norm_sed[&#39;FLUX&#39;] = 3631.0
            
            for band, k_correction in zip(self.bands, k_corrections):
                
                # Calculate the apparent magnitude
                norm = self._integrate_through_band(norm_sed, band, redshift, frame=&#39;REST&#39;)
                absolute_ab_mag = self._integrate_through_band(nite_sed, band, redshift, frame=&#39;REST&#39;) / norm
                output_data.append([nite, band, -2.5 * np.log10(absolute_ab_mag) + distance_modulus + k_correction])
                
        return {&#39;lc&#39;: pd.DataFrame(data=output_data, columns=output_data_cols).replace(np.nan, 30.0, inplace=False),
                &#39;obj_type&#39;: obj_type,
                &#39;sed&#39;: sed_filename}

    </code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="deeplenstronomy.timeseries.LCGen"><code class="flex name class">
<span>class <span class="ident">LCGen</span></span>
<span>(</span><span>bands='')</span>
</code></dt>
<dd>
<div class="desc"><p>Light Curve Generation</p>
<p>Initialize the LCGen object, download data if necessary, collect
necessary filter and sed information.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>bands</code></strong> :&ensp;<code>str</code></dt>
<dd>comma-separated string of bands, i.e. 'g,r,i,z'</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LCGen():
    &#34;&#34;&#34;Light Curve Generation&#34;&#34;&#34;    
    def __init__(self, bands=&#39;&#39;):
        &#34;&#34;&#34;
        Initialize the LCGen object, download data if necessary, collect 
        necessary filter and sed information.
        
        Args:
            bands (str): comma-separated string of bands, i.e. &#39;g,r,i,z&#39;
        &#34;&#34;&#34;
        # Check for filtes / seds and download if necessary
        self.__download_data()
        
        # Collect sed files
        self.ia_sed_files = glob.glob(&#39;seds/ia/*.dat&#39;)
        self.cc_sed_files = glob.glob(&#39;seds/cc/*.SED&#39;)
        self.__read_cc_weights()
        
        # Collect filter transmission curves
        self.filter_files = glob.glob(&#39;filters/*.dat&#39;)
        self.bands = bands.split(&#39;,&#39;)
        
        # Interpolate the transmission curves
        for band in self.bands:
            transmission_frequency, transmission_wavelength = self.__read_passband(band)
            setattr(self, &#39;{0}_transmission_frequency&#39;.format(band), transmission_frequency)
            setattr(self, &#39;{0}_transmission_wavelength&#39;.format(band), transmission_wavelength)
        
        return

    def __download_data(self):
        &#34;&#34;&#34;
        Check for required data and download if it is missing
        &#34;&#34;&#34;
        if not os.path.exists(&#39;seds&#39;):
            os.mkdir(&#39;seds&#39;)
        if not os.path.exists(&#39;seds/ia&#39;):
            os.system(&#39;svn checkout https://github.com/rmorgan10/deeplenstronomy_data/trunk/seds/ia&#39;)
            os.system(&#39;mv ia seds&#39;)
        if not os.path.exists(&#39;seds/cc&#39;):
            os.system(&#39;svn checkout https://github.com/rmorgan10/deeplenstronomy_data/trunk/seds/cc&#39;)
            os.system(&#39;mv cc seds&#39;)
        if not os.path.exists(&#39;seds/kn&#39;):
            os.system(&#39;svn checkout https://github.com/rmorgan10/deeplenstronomy_data/trunk/seds/kn&#39;)
            os.system(&#39;mv kn seds&#39;)
        if not os.path.exists(&#39;filters&#39;):
            os.system(&#39;svn checkout https://github.com/rmorgan10/deeplenstronomy_data/trunk/filters&#39;)
    
    def __read_cc_weights(self):
        &#34;&#34;&#34;
        Read Core-Collapse SNe metadata
        
        :assign cc_info_df: dataframe containing all CC template metadata
        :assign cc_weights: lists of weights for each template
        &#34;&#34;&#34;
        df = pd.read_csv(&#39;seds/cc/SIMGEN_INCLUDE_NON1A.INPUT&#39;, comment=&#39;#&#39;, delim_whitespace=True)
        self.cc_info_df = df
        self.cc_weights = [df[&#39;WGT&#39;].values[df[&#39;SED&#39;].values == x.split(&#39;/&#39;)[-1].split(&#39;.&#39;)[0]][0] for x in self.cc_sed_files]
        return
        
    
    def __read_passband(self, band):
        &#34;&#34;&#34;
        Read and interolate filter transmission curves
        
        :param band: the single-letter band identifier
        :return: transmisison_frequency: interpolated filter transmission as a function of frequency
        :return: transmisison_wavelength: interpolated filter transmission as a function of wavelength
        &#34;&#34;&#34;
        #Target filter file associated with band
        filter_file = [x for x in self.filter_files if x.find(&#39;_&#39; + band) != -1][0]
        
        # Read and format filter transmission info
        passband = pd.read_csv(filter_file, 
                               names=[&#39;WAVELENGTH&#39;, &#39;TRANSMISSION&#39;], 
                               delim_whitespace=True, comment=&#39;#&#39;)
        setattr(self, &#39;_{0}_obs_frame_freq_min&#39;.format(band), 2.99792458e18 / np.max(passband[&#39;WAVELENGTH&#39;].values))
        setattr(self, &#39;_{0}_obs_frame_freq_max&#39;.format(band), 2.99792458e18 / np.min(passband[&#39;WAVELENGTH&#39;].values))
        
        # Add boundary terms to cover the whole range
        passband.loc[passband.shape[0]] = (1.e-1, 0.0)
        passband.loc[passband.shape[0]] = (4.e+4, 0.0)
        
        # Convert to frequency using speed of light in angstroms
        passband[&#39;FREQUENCY&#39;] = 2.99792458e18 / passband[&#39;WAVELENGTH&#39;].values
        setattr(self, &#39;{0}_obs_frame_transmission&#39;.format(band), passband)
        
        # Interpolate and return
        transmission_frequency = interp1d(passband[&#39;FREQUENCY&#39;].values, passband[&#39;TRANSMISSION&#39;].values, fill_value=0.0)
        transmission_wavelength = interp1d(passband[&#39;WAVELENGTH&#39;].values, passband[&#39;TRANSMISSION&#39;].values, fill_value=0.0)
        return transmission_frequency, transmission_wavelength

    
    def _read_sed(self, sed_filename):
        &#34;&#34;&#34;
        Read a Spectral Enerrgy Distribution into a dataframe
        
        :param sed_filename: name of file describing the sed
        :return: sed: a dataframe of the sed
        &#34;&#34;&#34;
        
        # Read and format sed info
        sed = pd.read_csv(sed_filename,
                          names=[&#39;NITE&#39;, &#39;WAVELENGTH_REST&#39;, &#39;FLUX&#39;], 
                          delim_whitespace=True, comment=&#39;#&#39;)
        for nite in np.unique(sed[&#39;NITE&#39;].values):
            sed.loc[sed.shape[0]] = (nite, 10.0, 0.0)
            sed.loc[sed.shape[0]] = (nite, 25000.0, 0.0)
        sed[&#39;FREQUENCY_REST&#39;] = 2.99792458e18 / sed[&#39;WAVELENGTH_REST&#39;].values
        
        # Normalize
        func = interp1d(sed[&#39;WAVELENGTH_REST&#39;].values, sed[&#39;FLUX&#39;].values)
        sed[&#39;FLUX&#39;] = sed[&#39;FLUX&#39;].values / quad(func, 10.0, 25000.0)[0]
        
        # Round nights to nearest int
        sed[&#39;NITE&#39;] = [round(x) for x in sed[&#39;NITE&#39;].values]
        
        return sed
    
    def _get_kcorrect(self, sed, band, redshift):
        &#34;&#34;&#34;
        Calculate the K-Correction
        
        :param sed: the sed on the night of peak flux
        :param band: the single-letter band being used
        :param redshift: the redshift of the object
        :return: kcor: the k-correction to the absolute magnitude
        &#34;&#34;&#34;
        return -2.5 * np.log10((1.0 + redshift) * 
                               (self._integrate_through_band(sed, band, redshift, frame=&#39;OBS&#39;) /
                                self._integrate_through_band(sed, band, redshift, frame=&#39;REST&#39;)))
        
    def _get_distance_modulus(self, redshift, cosmo):
        &#34;&#34;&#34;
        Calculate the dimming effect of distance to the source
        
        :param redshift: the redshift of the object
        :param cosmo: an astropy.cosmology instance
        :return: dmod: the distance modulus contribution to the apparent magnitude
        &#34;&#34;&#34;
        return 5.0 * np.log10(cosmo.luminosity_distance(redshift).value * 10 ** 6 / 10)

    
    def _integrate_through_band(self, sed, band, redshift, frame=&#39;REST&#39;):
        &#34;&#34;&#34;
        Calculate the flux through a given band by integrating in frequency
        
        :param sed: a dataframe containing the sed of the object
        :param band: the single-letter filter being used
        :param redshift: the redshift of the source
        :param frame: chose from [&#39;REST&#39;, &#39;OBS&#39;] to choose the rest frame or the observer frame
        :return: flux: the measured flux from the source through the filter
        &#34;&#34;&#34;
        # Tighten bounds for accurate integration
        lower_bound = eval(&#39;self._{0}_obs_frame_freq_min&#39;.format(band))
        upper_bound = eval(&#39;self._{0}_obs_frame_freq_max&#39;.format(band))        
        frequency_arr = np.linspace(lower_bound, upper_bound, 100000)
        
        # Make an interpolated version of the integrand
        interpolated_sed = interp1d(sed[&#39;FREQUENCY_{0}&#39;.format(frame)].values, sed[&#39;FLUX&#39;].values, fill_value=0.0)
        integrand = eval(&#39;self.{0}_transmission_frequency(frequency_arr) * interpolated_sed(frequency_arr) / frequency_arr&#39;.format(band))
        interpolated_integrand = interp1d(frequency_arr, integrand, fill_value=0.0)
               
        # Integrate and return
        return quad(interpolated_integrand, lower_bound, upper_bound, limit=500)[0]
    
    def _get_closest_nite(self, unique_nites, nite):
        &#34;&#34;&#34;
        Return the nite in the sed closest to a desired nite
        
        :param unique_nites: a set of the nights in an sed
        :param nite: the nite you wish to find the closest neighbor for
        :return: closest_nite: the closest nite in the sed to the given nite
        &#34;&#34;&#34;
        return unique_nites[np.argmin(np.abs(nite - unique_nites))]

    def gen_variable(self, redshift, nites, sed=None, sed_filename=None, cosmo=None):
        &#34;&#34;&#34;
        Generate a random variable light curve

        Args:
            redshift (float): ignored 
            nites (List[int]): a list of night relative to peak you want to obtain a magnitude for    
            sed_filename (str): ignored
            cosmo (astropy.cosmology): ignored

        Returns:
            lc_dict: a dictionary with keys [&#39;lc, &#39;obj_type&#39;, &#39;sed&#39;]
              - &#39;lc&#39; contains a dataframe of the light from the object     
              - &#39;obj_type&#39; contains a string for the type of object. Will always be &#39;Variable&#39; here
              - &#39;sed&#39; contains the filename of the sed used. Will always be &#39;Variable&#39; here  
        &#34;&#34;&#34;
        output_data_cols = [&#39;NITE&#39;, &#39;BAND&#39;, &#39;MAG&#39;]
        output_data = []
        central_mag = random.uniform(12.0, 23.0)
        colors = {band: mag for band, mag in zip(self.bands, np.random.uniform(low=-2.0, high=2.0, size=len(self.bands)))}
        for nite in nites:
            central_mag = random.uniform(central_mag - 1.0, central_mag + 1.0)
            for band in self.bands:
                output_data.append([nite, band, central_mag + colors[band]])

        return {&#39;lc&#39;: pd.DataFrame(data=output_data, columns=output_data_cols),
                &#39;obj_type&#39;: &#39;Variable&#39;,
                &#39;sed&#39;: &#39;Variable&#39;}
    
    def gen_flat(self, redshift, nites, sed=None, sed_filename=None, cosmo=None):
        &#34;&#34;&#34;
        Generate a random flat light curve.
        
        Args:
            redshift (float): ignored
            nites (List[int]): a list of night relative to peak you want to obtain a magnitude for
            sed_filename (str): ignored
            cosmo (astropy.cosmology): ignored

        Returns:
            lc_dict: a dictionary with keys [&#39;lc, &#39;obj_type&#39;, &#39;sed&#39;]
              - &#39;lc&#39; contains a dataframe of the light from the object
              - &#39;obj_type&#39; contains a string for the type of object. Will always be &#39;Flat&#39; here
              - &#39;sed&#39; contains the filename of the sed used. Will always be &#39;Flat&#39; here      
        &#34;&#34;&#34;
        output_data_cols = [&#39;NITE&#39;, &#39;BAND&#39;, &#39;MAG&#39;]
        central_mag = random.uniform(12.0, 23.0)
        mags = {band: mag for band, mag in zip(self.bands, central_mag + np.random.uniform(low=-2.0, high=2.0, size=len(self.bands)))}
        output_data = []
        for nite in nites:
            for band in self.bands:
                output_data.append([nite, band, mags[band]])

        return {&#39;lc&#39;: pd.DataFrame(data=output_data, columns=output_data_cols),
                &#39;obj_type&#39;: &#39;Flat&#39;,
                &#39;sed&#39;: &#39;Flat&#39;}

    def gen_static(self, redshift, nites, sed=None, sed_filename=None, cosmo=None):
        &#34;&#34;&#34;
        Make a static source capable of having time-series data by introducing a mag=99 source
        on each NITE of the simulation.

        Args:
            redshift (float): ignored 
            nites (List[int]): a list of night relative to peak you want to obtain a magnitude for
            sed_filename (str): ignored                                                                                                                                                               
            cosmo (astropy.cosmology): ignored                                                                                                                                                                                            
        Returns:
            lc_dict: a dictionary with keys [&#39;lc, &#39;obj_type&#39;, &#39;sed&#39;]
              - &#39;lc&#39; contains a dataframe of the light from the object
              - &#39;obj_type&#39; contains a string for the type of object. Will always be &#39;Static&#39; here
              - &#39;sed&#39; contains the filename of the sed used. Will always be &#39;Flat&#39; here                                                                                                                        &#34;&#34;&#34;
        output_data_cols = [&#39;NITE&#39;, &#39;BAND&#39;, &#39;MAG&#39;]
        central_mag = 99.0
        mags = {band: central_mag for band in self.bands}
        output_data = []
        for nite in nites:
            for band in self.bands:
                output_data.append([nite, band, mags[band]])

        return {&#39;lc&#39;: pd.DataFrame(data=output_data, columns=output_data_cols),
                &#39;obj_type&#39;: &#39;Static&#39;,
                &#39;sed&#39;: &#39;Static&#39;}


        
    def gen_variablenoise(self, redshift, nites, sed=None, sed_filename=None, cosmo=None):
        &#34;&#34;&#34; 
        Generate a variable light curve with small random noise

        Args:
            redshift (float): ignored
            nites (List[int]): a list of night relative to peak you want to obtain a magnitude for
            sed_filename (str): ignored
            cosmo (astropy.cosmology): ignored

        Returns:
            lc_dict: a dictionary with keys [&#39;lc, &#39;obj_type&#39;, &#39;sed&#39;]
              - &#39;lc&#39; contains a dataframe of the light from the object
              - &#39;obj_type&#39; contains a string for the type of object. Will always be &#39;VariableNoise&#39; here
              - &#39;sed&#39; contains the filename of the sed used. Will always be &#39;VariableNoise&#39; here              
        &#34;&#34;&#34;
        noiseless_lc_dict = self.gen_variable(redshift, nites)
        noise = np.random.normal(loc=0, scale=0.25, size=noiseless_lc_dict[&#39;lc&#39;].shape[0])
        noiseless_lc_dict[&#39;lc&#39;][&#39;MAG&#39;] = noiseless_lc_dict[&#39;lc&#39;][&#39;MAG&#39;].values + noise
        noiseless_lc_dict[&#39;obj_type&#39;] = &#39;VariableNoise&#39;
        noiseless_lc_dict[&#39;sed&#39;] = &#39;VariableNoise&#39;
        return noiseless_lc_dict

    
    def gen_flatnoise(self, redshift, nites, sed=None, sed_filename=None, cosmo=None):
        &#34;&#34;&#34;
        Generate a flat light curve will small random noise

        Args:
            redshift (float): ignored
            nites (List[int]): a list of night relative to peak you want to obtain a magnitude for
            sed_filename (str): ignored
            cosmo (astropy.cosmology): ignored

        Returns:
            lc_dict: a dictionary with keys [&#39;lc, &#39;obj_type&#39;, &#39;sed&#39;]
              - &#39;lc&#39; contains a dataframe of the light from the object
              - &#39;obj_type&#39; contains a string for the type of object. Will always be &#39;FlatNoise&#39; here
              - &#39;sed&#39; contains the filename of the sed used. Will always be &#39;FlatNoise&#39; here              
        &#34;&#34;&#34;
        noiseless_lc_dict = self.gen_flat(redshift, nites)
        noise = np.random.normal(loc=0, scale=0.25, size=noiseless_lc_dict[&#39;lc&#39;].shape[0])
        noiseless_lc_dict[&#39;lc&#39;][&#39;MAG&#39;] = noiseless_lc_dict[&#39;lc&#39;][&#39;MAG&#39;].values + noise
        noiseless_lc_dict[&#39;obj_type&#39;] = &#39;FlatNoise&#39;
        noiseless_lc_dict[&#39;sed&#39;] = &#39;FlatNoise&#39;
        return noiseless_lc_dict
        
    def gen_user(self, redshift, nites, sed=None, sed_filename=None, cosmo=None):
        &#34;&#34;&#34;
        Generate a light curve from a user-specidied SED

        Args:
            redshift (float): the redshift of the source
            nites (List[int]): a list of night relative to peak you want to obtain a magnitude for 
            sed (None or pandas.DataFrame, optional, default=None): a dataframe containing the sed of the SN 
            sed_filename (str): filename containing the time-series sed you want to use 
            cosmo (astropy.cosmology): an astropy.cosmology instance used for distance calculations

        Returns:
            lc_dict: a dictionary with keys [&#39;lc, &#39;obj_type&#39;, &#39;sed&#39;]
              - &#39;lc&#39; contains a dataframe of the light from the object
              - &#39;obj_type&#39; contains a string for the type of object. Will always be &lt;sed_filename&gt; here 
              - &#39;sed&#39; contains the filename of the sed used  
        &#34;&#34;&#34;
        if not sed:
            sed = self._read_sed(&#39;seds/user/&#39; + sed_filename)

        return self.gen_lc_from_sed(redshift, nites, sed, sed_filename, sed_filename, cosmo=cosmo)

    def gen_kn(self, redshift, nites, sed=None, sed_filename=None, cosmo=None):
        &#34;&#34;&#34;
        Generate a GW170817-like light curve.

        Args:
            redshift (float): the redshift of the source
            nites (List[int]): a list of night relative to peak you want to obtain a magnitude for 
            sed (None or pandas.DataFrame, optional, default=None): a dataframe containing the sed of the SN 
            sed_filename (str): filename containing the time-series sed you want to use 
            cosmo (astropy.cosmology): an astropy.cosmology instance used for distance calculations

        Returns:
            lc_dict: a dictionary with keys [&#39;lc, &#39;obj_type&#39;, &#39;sed&#39;]
              - &#39;lc&#39; contains a dataframe of the light from the object
              - &#39;obj_type&#39; contains a string for the type of object. Will always be KN here 
              - &#39;sed&#39; contains the filename of the sed used  
        &#34;&#34;&#34;

        sed_filename = &#39;seds/kn/kn.SED&#39;
        if not sed:
            sed = self._read_sed(sed_filename)

        return self.gen_lc_from_sed(redshift, nites, sed, &#39;KN&#39;, sed_filename, cosmo=cosmo)
    
    def gen_ia(self, redshift, nites, sed=None, sed_filename=None, cosmo=None):
        &#34;&#34;&#34;
        Generate a SN-Ia light curve.
        

        Args:
            redshift (float): the redshift of the source
            nites (List[int]): a list of night relative to peak you want to obtain a magnitude for 
            sed (None or pandas.DataFrame, optional, default=None): a dataframe containing the sed of the SN 
            sed_filename (str): filename containing the time-series sed you want to use 
            cosmo (astropy.cosmology): an astropy.cosmology instance used for distance calculations

        Returns:
            lc_dict: a dictionary with keys [&#39;lc, &#39;obj_type&#39;, &#39;sed&#39;]
              - &#39;lc&#39; contains a dataframe of the light from the object
              - &#39;obj_type&#39; contains a string for the type of object. Will always be Ia here 
              - &#39;sed&#39; contains the filename of the sed used  
        &#34;&#34;&#34;
        
        # Read rest-frame sed if not supplied as argument
        if not sed:
            if sed_filename:
                sed = self._read_sed(&#39;seds/ia/&#39; + sed_filename)
            else:
                sed_filename = random.choice(self.ia_sed_files)
                sed = self._read_sed(sed_filename)
                
        # Trigger the lc generation function on this sed
        return self.gen_lc_from_sed(redshift, nites, sed, &#39;Ia&#39;, sed_filename, cosmo=cosmo)
    
    def gen_cc(self, redshift, nites, sed=None, sed_filename=None, cosmo=None):
        &#34;&#34;&#34;
        Generate a SN-CC light curve
        
        Args:
            redshift (float): the redshift of the source
            nites (List[int]): a list of night relative to peak you want to obtain a magnitude for 
            sed (None or pandas.DataFrame, optional, default=None): a dataframe containing the sed of the SN 
            sed_filename (str): filename containing the time-series sed you want to use 
            cosmo (astropy.cosmology): an astropy.cosmology instance used for distance calculations

        Returns:
            lc_dict: a dictionary with keys [&#39;lc, &#39;obj_type&#39;, &#39;sed&#39;]
              - &#39;lc&#39; contains a dataframe of the light from the object
              - &#39;obj_type&#39; contains a string for the type of object. Will be &#39;II&#39;, &#39;Ibc, etc. 
              - &#39;sed&#39; contains the filename of the sed used  
        &#34;&#34;&#34;

        # If sed not specified, choose sed based on weight map
        if not sed:
            if sed_filename:
                sed = self._read_sed(&#39;seds/cc/&#39; + sed_filename)
            else:
                sed_filename = random.choices(self.cc_sed_files, weights=self.cc_weights, k=1)[0]
                sed = self._read_sed(sed_filename)
        
        # Get the type of SN-CC
        obj_type = self.cc_info_df[&#39;SNTYPE&#39;].values[self.cc_info_df[&#39;SED&#39;].values == sed_filename.split(&#39;/&#39;)[-1].split(&#39;.&#39;)[0]][0]
        
        # Trigger the lc generation function on this sed
        return self.gen_lc_from_sed(redshift, nites, sed, obj_type, sed_filename, cosmo=cosmo)
                
    def gen_lc_from_sed(self, redshift, nites, sed, obj_type, sed_filename, cosmo=None):
        &#34;&#34;&#34;
        Generate a light curve based on a time-series sed.
        
        Args:
            redshift (float): the redshift of the source
            nites (List[int]): a list of night relative to peak you want to obtain a magnitude for 
            sed (None or pandas.DataFrame, optional, default=None): a dataframe containing the sed of the SN 
            sed_filename (str): filename containing the time-series sed you want to use 
            cosmo (astropy.cosmology): an astropy.cosmology instance used for distance calculations

        Returns:
            lc_dict: a dictionary with keys [&#39;lc, &#39;obj_type&#39;, &#39;sed&#39;]
              - &#39;lc&#39; contains a dataframe of the light from the object
              - &#39;obj_type&#39; contains a string for the type of object. 
              - &#39;sed&#39; contains the filename of the sed used  
        &#34;&#34;&#34;
        
        # If nite not in the sed, set nite to the closest nite in the sed
        useable_nites = []
        sed_nites = np.unique(sed[&#39;NITE&#39;].values)
        for nite in nites:
            if nite not in sed_nites:
                useable_nites.append(self._get_closest_nite(sed_nites, nite))
            else:
                useable_nites.append(nite)
        nites = useable_nites
            
        # Redshift the sed frequencies and wavelengths
        sed[&#39;WAVELENGTH_OBS&#39;] = (1.0 + redshift) * sed[&#39;WAVELENGTH_REST&#39;].values
        sed[&#39;FREQUENCY_OBS&#39;] = sed[&#39;FREQUENCY_REST&#39;].values * (1.0 + redshift)
        
        # Calculate distance modulus
        if not cosmo:
            cosmo = FlatLambdaCDM(H0=69.3 * u.km / (u.Mpc * u.s), 
                                  Om0=0.286, Tcmb0=2.725 * u.K, Neff=3.04, Ob0=0.0463)
        distance_modulus = self._get_distance_modulus(redshift, cosmo=cosmo)
        
        # Calculate k-correction at peak
        peak_sed = sed[sed[&#39;NITE&#39;].values == self._get_closest_nite(np.unique(sed[&#39;NITE&#39;].values), 0)].copy().reset_index(drop=True)
        k_corrections = [self._get_kcorrect(peak_sed, band, redshift) for band in self.bands]
        
        # On each nite, in each band, calculate the absolute mag
        output_data = []
        output_data_cols = [&#39;NITE&#39;, &#39;BAND&#39;, &#39;MAG&#39;]
        for nite in nites:
            nite_sed = sed[sed[&#39;NITE&#39;].values == nite].copy().reset_index(drop=True)
            
            # Apply factors to calculate absolute mag
            nite_sed[&#39;FLUX&#39;] = (cosmo.luminosity_distance(redshift).value * 10 ** 6 / 10) ** 2 / (1 + redshift) * nite_sed[&#39;FLUX&#39;].values
            nite_sed[&#39;FREQUENCY_REST&#39;] = nite_sed[&#39;FREQUENCY_REST&#39;].values / (1. + redshift)
            
            # Convert to AB Magnitude system
            norm_sed = nite_sed.copy()
            norm_sed[&#39;FLUX&#39;] = 3631.0
            
            for band, k_correction in zip(self.bands, k_corrections):
                
                # Calculate the apparent magnitude
                norm = self._integrate_through_band(norm_sed, band, redshift, frame=&#39;REST&#39;)
                absolute_ab_mag = self._integrate_through_band(nite_sed, band, redshift, frame=&#39;REST&#39;) / norm
                output_data.append([nite, band, -2.5 * np.log10(absolute_ab_mag) + distance_modulus + k_correction])
                
        return {&#39;lc&#39;: pd.DataFrame(data=output_data, columns=output_data_cols).replace(np.nan, 30.0, inplace=False),
                &#39;obj_type&#39;: obj_type,
                &#39;sed&#39;: sed_filename}</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="deeplenstronomy.timeseries.LCGen.gen_cc"><code class="name flex">
<span>def <span class="ident">gen_cc</span></span>(<span>self, redshift, nites, sed=None, sed_filename=None, cosmo=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate a SN-CC light curve</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>redshift</code></strong> :&ensp;<code>float</code></dt>
<dd>the redshift of the source</dd>
<dt><strong><code>nites</code></strong> :&ensp;<code>List[int]</code></dt>
<dd>a list of night relative to peak you want to obtain a magnitude for </dd>
<dt><strong><code>sed</code></strong> :&ensp;<code>None</code> or <code>pandas.DataFrame</code>, optional, default=<code>None</code></dt>
<dd>a dataframe containing the sed of the SN </dd>
<dt><strong><code>sed_filename</code></strong> :&ensp;<code>str</code></dt>
<dd>filename containing the time-series sed you want to use </dd>
<dt><strong><code>cosmo</code></strong> :&ensp;<code>astropy.cosmology</code></dt>
<dd>an astropy.cosmology instance used for distance calculations</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>lc_dict</code></dt>
<dd>a dictionary with keys ['lc, 'obj_type', 'sed']
- 'lc' contains a dataframe of the light from the object
- 'obj_type' contains a string for the type of object. Will be 'II', 'Ibc, etc.
- 'sed' contains the filename of the sed used</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def gen_cc(self, redshift, nites, sed=None, sed_filename=None, cosmo=None):
    &#34;&#34;&#34;
    Generate a SN-CC light curve
    
    Args:
        redshift (float): the redshift of the source
        nites (List[int]): a list of night relative to peak you want to obtain a magnitude for 
        sed (None or pandas.DataFrame, optional, default=None): a dataframe containing the sed of the SN 
        sed_filename (str): filename containing the time-series sed you want to use 
        cosmo (astropy.cosmology): an astropy.cosmology instance used for distance calculations

    Returns:
        lc_dict: a dictionary with keys [&#39;lc, &#39;obj_type&#39;, &#39;sed&#39;]
          - &#39;lc&#39; contains a dataframe of the light from the object
          - &#39;obj_type&#39; contains a string for the type of object. Will be &#39;II&#39;, &#39;Ibc, etc. 
          - &#39;sed&#39; contains the filename of the sed used  
    &#34;&#34;&#34;

    # If sed not specified, choose sed based on weight map
    if not sed:
        if sed_filename:
            sed = self._read_sed(&#39;seds/cc/&#39; + sed_filename)
        else:
            sed_filename = random.choices(self.cc_sed_files, weights=self.cc_weights, k=1)[0]
            sed = self._read_sed(sed_filename)
    
    # Get the type of SN-CC
    obj_type = self.cc_info_df[&#39;SNTYPE&#39;].values[self.cc_info_df[&#39;SED&#39;].values == sed_filename.split(&#39;/&#39;)[-1].split(&#39;.&#39;)[0]][0]
    
    # Trigger the lc generation function on this sed
    return self.gen_lc_from_sed(redshift, nites, sed, obj_type, sed_filename, cosmo=cosmo)</code></pre>
</details>
</dd>
<dt id="deeplenstronomy.timeseries.LCGen.gen_flat"><code class="name flex">
<span>def <span class="ident">gen_flat</span></span>(<span>self, redshift, nites, sed=None, sed_filename=None, cosmo=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate a random flat light curve.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>redshift</code></strong> :&ensp;<code>float</code></dt>
<dd>ignored</dd>
<dt><strong><code>nites</code></strong> :&ensp;<code>List[int]</code></dt>
<dd>a list of night relative to peak you want to obtain a magnitude for</dd>
<dt><strong><code>sed_filename</code></strong> :&ensp;<code>str</code></dt>
<dd>ignored</dd>
<dt><strong><code>cosmo</code></strong> :&ensp;<code>astropy.cosmology</code></dt>
<dd>ignored</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>lc_dict</code></dt>
<dd>a dictionary with keys ['lc, 'obj_type', 'sed']
- 'lc' contains a dataframe of the light from the object
- 'obj_type' contains a string for the type of object. Will always be 'Flat' here
- 'sed' contains the filename of the sed used. Will always be 'Flat' here</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def gen_flat(self, redshift, nites, sed=None, sed_filename=None, cosmo=None):
    &#34;&#34;&#34;
    Generate a random flat light curve.
    
    Args:
        redshift (float): ignored
        nites (List[int]): a list of night relative to peak you want to obtain a magnitude for
        sed_filename (str): ignored
        cosmo (astropy.cosmology): ignored

    Returns:
        lc_dict: a dictionary with keys [&#39;lc, &#39;obj_type&#39;, &#39;sed&#39;]
          - &#39;lc&#39; contains a dataframe of the light from the object
          - &#39;obj_type&#39; contains a string for the type of object. Will always be &#39;Flat&#39; here
          - &#39;sed&#39; contains the filename of the sed used. Will always be &#39;Flat&#39; here      
    &#34;&#34;&#34;
    output_data_cols = [&#39;NITE&#39;, &#39;BAND&#39;, &#39;MAG&#39;]
    central_mag = random.uniform(12.0, 23.0)
    mags = {band: mag for band, mag in zip(self.bands, central_mag + np.random.uniform(low=-2.0, high=2.0, size=len(self.bands)))}
    output_data = []
    for nite in nites:
        for band in self.bands:
            output_data.append([nite, band, mags[band]])

    return {&#39;lc&#39;: pd.DataFrame(data=output_data, columns=output_data_cols),
            &#39;obj_type&#39;: &#39;Flat&#39;,
            &#39;sed&#39;: &#39;Flat&#39;}</code></pre>
</details>
</dd>
<dt id="deeplenstronomy.timeseries.LCGen.gen_flatnoise"><code class="name flex">
<span>def <span class="ident">gen_flatnoise</span></span>(<span>self, redshift, nites, sed=None, sed_filename=None, cosmo=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate a flat light curve will small random noise</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>redshift</code></strong> :&ensp;<code>float</code></dt>
<dd>ignored</dd>
<dt><strong><code>nites</code></strong> :&ensp;<code>List[int]</code></dt>
<dd>a list of night relative to peak you want to obtain a magnitude for</dd>
<dt><strong><code>sed_filename</code></strong> :&ensp;<code>str</code></dt>
<dd>ignored</dd>
<dt><strong><code>cosmo</code></strong> :&ensp;<code>astropy.cosmology</code></dt>
<dd>ignored</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>lc_dict</code></dt>
<dd>a dictionary with keys ['lc, 'obj_type', 'sed']
- 'lc' contains a dataframe of the light from the object
- 'obj_type' contains a string for the type of object. Will always be 'FlatNoise' here
- 'sed' contains the filename of the sed used. Will always be 'FlatNoise' here</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def gen_flatnoise(self, redshift, nites, sed=None, sed_filename=None, cosmo=None):
    &#34;&#34;&#34;
    Generate a flat light curve will small random noise

    Args:
        redshift (float): ignored
        nites (List[int]): a list of night relative to peak you want to obtain a magnitude for
        sed_filename (str): ignored
        cosmo (astropy.cosmology): ignored

    Returns:
        lc_dict: a dictionary with keys [&#39;lc, &#39;obj_type&#39;, &#39;sed&#39;]
          - &#39;lc&#39; contains a dataframe of the light from the object
          - &#39;obj_type&#39; contains a string for the type of object. Will always be &#39;FlatNoise&#39; here
          - &#39;sed&#39; contains the filename of the sed used. Will always be &#39;FlatNoise&#39; here              
    &#34;&#34;&#34;
    noiseless_lc_dict = self.gen_flat(redshift, nites)
    noise = np.random.normal(loc=0, scale=0.25, size=noiseless_lc_dict[&#39;lc&#39;].shape[0])
    noiseless_lc_dict[&#39;lc&#39;][&#39;MAG&#39;] = noiseless_lc_dict[&#39;lc&#39;][&#39;MAG&#39;].values + noise
    noiseless_lc_dict[&#39;obj_type&#39;] = &#39;FlatNoise&#39;
    noiseless_lc_dict[&#39;sed&#39;] = &#39;FlatNoise&#39;
    return noiseless_lc_dict</code></pre>
</details>
</dd>
<dt id="deeplenstronomy.timeseries.LCGen.gen_ia"><code class="name flex">
<span>def <span class="ident">gen_ia</span></span>(<span>self, redshift, nites, sed=None, sed_filename=None, cosmo=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate a SN-Ia light curve.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>redshift</code></strong> :&ensp;<code>float</code></dt>
<dd>the redshift of the source</dd>
<dt><strong><code>nites</code></strong> :&ensp;<code>List[int]</code></dt>
<dd>a list of night relative to peak you want to obtain a magnitude for </dd>
<dt><strong><code>sed</code></strong> :&ensp;<code>None</code> or <code>pandas.DataFrame</code>, optional, default=<code>None</code></dt>
<dd>a dataframe containing the sed of the SN </dd>
<dt><strong><code>sed_filename</code></strong> :&ensp;<code>str</code></dt>
<dd>filename containing the time-series sed you want to use </dd>
<dt><strong><code>cosmo</code></strong> :&ensp;<code>astropy.cosmology</code></dt>
<dd>an astropy.cosmology instance used for distance calculations</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>lc_dict</code></dt>
<dd>a dictionary with keys ['lc, 'obj_type', 'sed']
- 'lc' contains a dataframe of the light from the object
- 'obj_type' contains a string for the type of object. Will always be Ia here
- 'sed' contains the filename of the sed used</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def gen_ia(self, redshift, nites, sed=None, sed_filename=None, cosmo=None):
    &#34;&#34;&#34;
    Generate a SN-Ia light curve.
    

    Args:
        redshift (float): the redshift of the source
        nites (List[int]): a list of night relative to peak you want to obtain a magnitude for 
        sed (None or pandas.DataFrame, optional, default=None): a dataframe containing the sed of the SN 
        sed_filename (str): filename containing the time-series sed you want to use 
        cosmo (astropy.cosmology): an astropy.cosmology instance used for distance calculations

    Returns:
        lc_dict: a dictionary with keys [&#39;lc, &#39;obj_type&#39;, &#39;sed&#39;]
          - &#39;lc&#39; contains a dataframe of the light from the object
          - &#39;obj_type&#39; contains a string for the type of object. Will always be Ia here 
          - &#39;sed&#39; contains the filename of the sed used  
    &#34;&#34;&#34;
    
    # Read rest-frame sed if not supplied as argument
    if not sed:
        if sed_filename:
            sed = self._read_sed(&#39;seds/ia/&#39; + sed_filename)
        else:
            sed_filename = random.choice(self.ia_sed_files)
            sed = self._read_sed(sed_filename)
            
    # Trigger the lc generation function on this sed
    return self.gen_lc_from_sed(redshift, nites, sed, &#39;Ia&#39;, sed_filename, cosmo=cosmo)</code></pre>
</details>
</dd>
<dt id="deeplenstronomy.timeseries.LCGen.gen_kn"><code class="name flex">
<span>def <span class="ident">gen_kn</span></span>(<span>self, redshift, nites, sed=None, sed_filename=None, cosmo=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate a GW170817-like light curve.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>redshift</code></strong> :&ensp;<code>float</code></dt>
<dd>the redshift of the source</dd>
<dt><strong><code>nites</code></strong> :&ensp;<code>List[int]</code></dt>
<dd>a list of night relative to peak you want to obtain a magnitude for </dd>
<dt><strong><code>sed</code></strong> :&ensp;<code>None</code> or <code>pandas.DataFrame</code>, optional, default=<code>None</code></dt>
<dd>a dataframe containing the sed of the SN </dd>
<dt><strong><code>sed_filename</code></strong> :&ensp;<code>str</code></dt>
<dd>filename containing the time-series sed you want to use </dd>
<dt><strong><code>cosmo</code></strong> :&ensp;<code>astropy.cosmology</code></dt>
<dd>an astropy.cosmology instance used for distance calculations</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>lc_dict</code></dt>
<dd>a dictionary with keys ['lc, 'obj_type', 'sed']
- 'lc' contains a dataframe of the light from the object
- 'obj_type' contains a string for the type of object. Will always be KN here
- 'sed' contains the filename of the sed used</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def gen_kn(self, redshift, nites, sed=None, sed_filename=None, cosmo=None):
    &#34;&#34;&#34;
    Generate a GW170817-like light curve.

    Args:
        redshift (float): the redshift of the source
        nites (List[int]): a list of night relative to peak you want to obtain a magnitude for 
        sed (None or pandas.DataFrame, optional, default=None): a dataframe containing the sed of the SN 
        sed_filename (str): filename containing the time-series sed you want to use 
        cosmo (astropy.cosmology): an astropy.cosmology instance used for distance calculations

    Returns:
        lc_dict: a dictionary with keys [&#39;lc, &#39;obj_type&#39;, &#39;sed&#39;]
          - &#39;lc&#39; contains a dataframe of the light from the object
          - &#39;obj_type&#39; contains a string for the type of object. Will always be KN here 
          - &#39;sed&#39; contains the filename of the sed used  
    &#34;&#34;&#34;

    sed_filename = &#39;seds/kn/kn.SED&#39;
    if not sed:
        sed = self._read_sed(sed_filename)

    return self.gen_lc_from_sed(redshift, nites, sed, &#39;KN&#39;, sed_filename, cosmo=cosmo)</code></pre>
</details>
</dd>
<dt id="deeplenstronomy.timeseries.LCGen.gen_lc_from_sed"><code class="name flex">
<span>def <span class="ident">gen_lc_from_sed</span></span>(<span>self, redshift, nites, sed, obj_type, sed_filename, cosmo=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate a light curve based on a time-series sed.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>redshift</code></strong> :&ensp;<code>float</code></dt>
<dd>the redshift of the source</dd>
<dt><strong><code>nites</code></strong> :&ensp;<code>List[int]</code></dt>
<dd>a list of night relative to peak you want to obtain a magnitude for </dd>
<dt><strong><code>sed</code></strong> :&ensp;<code>None</code> or <code>pandas.DataFrame</code>, optional, default=<code>None</code></dt>
<dd>a dataframe containing the sed of the SN </dd>
<dt><strong><code>sed_filename</code></strong> :&ensp;<code>str</code></dt>
<dd>filename containing the time-series sed you want to use </dd>
<dt><strong><code>cosmo</code></strong> :&ensp;<code>astropy.cosmology</code></dt>
<dd>an astropy.cosmology instance used for distance calculations</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>lc_dict</code></dt>
<dd>a dictionary with keys ['lc, 'obj_type', 'sed']
- 'lc' contains a dataframe of the light from the object
- 'obj_type' contains a string for the type of object.
- 'sed' contains the filename of the sed used</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def gen_lc_from_sed(self, redshift, nites, sed, obj_type, sed_filename, cosmo=None):
    &#34;&#34;&#34;
    Generate a light curve based on a time-series sed.
    
    Args:
        redshift (float): the redshift of the source
        nites (List[int]): a list of night relative to peak you want to obtain a magnitude for 
        sed (None or pandas.DataFrame, optional, default=None): a dataframe containing the sed of the SN 
        sed_filename (str): filename containing the time-series sed you want to use 
        cosmo (astropy.cosmology): an astropy.cosmology instance used for distance calculations

    Returns:
        lc_dict: a dictionary with keys [&#39;lc, &#39;obj_type&#39;, &#39;sed&#39;]
          - &#39;lc&#39; contains a dataframe of the light from the object
          - &#39;obj_type&#39; contains a string for the type of object. 
          - &#39;sed&#39; contains the filename of the sed used  
    &#34;&#34;&#34;
    
    # If nite not in the sed, set nite to the closest nite in the sed
    useable_nites = []
    sed_nites = np.unique(sed[&#39;NITE&#39;].values)
    for nite in nites:
        if nite not in sed_nites:
            useable_nites.append(self._get_closest_nite(sed_nites, nite))
        else:
            useable_nites.append(nite)
    nites = useable_nites
        
    # Redshift the sed frequencies and wavelengths
    sed[&#39;WAVELENGTH_OBS&#39;] = (1.0 + redshift) * sed[&#39;WAVELENGTH_REST&#39;].values
    sed[&#39;FREQUENCY_OBS&#39;] = sed[&#39;FREQUENCY_REST&#39;].values * (1.0 + redshift)
    
    # Calculate distance modulus
    if not cosmo:
        cosmo = FlatLambdaCDM(H0=69.3 * u.km / (u.Mpc * u.s), 
                              Om0=0.286, Tcmb0=2.725 * u.K, Neff=3.04, Ob0=0.0463)
    distance_modulus = self._get_distance_modulus(redshift, cosmo=cosmo)
    
    # Calculate k-correction at peak
    peak_sed = sed[sed[&#39;NITE&#39;].values == self._get_closest_nite(np.unique(sed[&#39;NITE&#39;].values), 0)].copy().reset_index(drop=True)
    k_corrections = [self._get_kcorrect(peak_sed, band, redshift) for band in self.bands]
    
    # On each nite, in each band, calculate the absolute mag
    output_data = []
    output_data_cols = [&#39;NITE&#39;, &#39;BAND&#39;, &#39;MAG&#39;]
    for nite in nites:
        nite_sed = sed[sed[&#39;NITE&#39;].values == nite].copy().reset_index(drop=True)
        
        # Apply factors to calculate absolute mag
        nite_sed[&#39;FLUX&#39;] = (cosmo.luminosity_distance(redshift).value * 10 ** 6 / 10) ** 2 / (1 + redshift) * nite_sed[&#39;FLUX&#39;].values
        nite_sed[&#39;FREQUENCY_REST&#39;] = nite_sed[&#39;FREQUENCY_REST&#39;].values / (1. + redshift)
        
        # Convert to AB Magnitude system
        norm_sed = nite_sed.copy()
        norm_sed[&#39;FLUX&#39;] = 3631.0
        
        for band, k_correction in zip(self.bands, k_corrections):
            
            # Calculate the apparent magnitude
            norm = self._integrate_through_band(norm_sed, band, redshift, frame=&#39;REST&#39;)
            absolute_ab_mag = self._integrate_through_band(nite_sed, band, redshift, frame=&#39;REST&#39;) / norm
            output_data.append([nite, band, -2.5 * np.log10(absolute_ab_mag) + distance_modulus + k_correction])
            
    return {&#39;lc&#39;: pd.DataFrame(data=output_data, columns=output_data_cols).replace(np.nan, 30.0, inplace=False),
            &#39;obj_type&#39;: obj_type,
            &#39;sed&#39;: sed_filename}</code></pre>
</details>
</dd>
<dt id="deeplenstronomy.timeseries.LCGen.gen_static"><code class="name flex">
<span>def <span class="ident">gen_static</span></span>(<span>self, redshift, nites, sed=None, sed_filename=None, cosmo=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Make a static source capable of having time-series data by introducing a mag=99 source
on each NITE of the simulation.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>redshift</code></strong> :&ensp;<code>float</code></dt>
<dd>ignored </dd>
<dt><strong><code>nites</code></strong> :&ensp;<code>List[int]</code></dt>
<dd>a list of night relative to peak you want to obtain a magnitude for</dd>
<dt><strong><code>sed_filename</code></strong> :&ensp;<code>str</code></dt>
<dd>ignored
</dd>
<dt><strong><code>cosmo</code></strong> :&ensp;<code>astropy.cosmology</code></dt>
<dd>ignored
</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>lc_dict</code></dt>
<dd>a dictionary with keys ['lc, 'obj_type', 'sed']
- 'lc' contains a dataframe of the light from the object
- 'obj_type' contains a string for the type of object. Will always be 'Static' here
- 'sed' contains the filename of the sed used. Will always be 'Flat' here</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def gen_static(self, redshift, nites, sed=None, sed_filename=None, cosmo=None):
    &#34;&#34;&#34;
    Make a static source capable of having time-series data by introducing a mag=99 source
    on each NITE of the simulation.

    Args:
        redshift (float): ignored 
        nites (List[int]): a list of night relative to peak you want to obtain a magnitude for
        sed_filename (str): ignored                                                                                                                                                               
        cosmo (astropy.cosmology): ignored                                                                                                                                                                                            
    Returns:
        lc_dict: a dictionary with keys [&#39;lc, &#39;obj_type&#39;, &#39;sed&#39;]
          - &#39;lc&#39; contains a dataframe of the light from the object
          - &#39;obj_type&#39; contains a string for the type of object. Will always be &#39;Static&#39; here
          - &#39;sed&#39; contains the filename of the sed used. Will always be &#39;Flat&#39; here                                                                                                                        &#34;&#34;&#34;
    output_data_cols = [&#39;NITE&#39;, &#39;BAND&#39;, &#39;MAG&#39;]
    central_mag = 99.0
    mags = {band: central_mag for band in self.bands}
    output_data = []
    for nite in nites:
        for band in self.bands:
            output_data.append([nite, band, mags[band]])

    return {&#39;lc&#39;: pd.DataFrame(data=output_data, columns=output_data_cols),
            &#39;obj_type&#39;: &#39;Static&#39;,
            &#39;sed&#39;: &#39;Static&#39;}</code></pre>
</details>
</dd>
<dt id="deeplenstronomy.timeseries.LCGen.gen_user"><code class="name flex">
<span>def <span class="ident">gen_user</span></span>(<span>self, redshift, nites, sed=None, sed_filename=None, cosmo=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate a light curve from a user-specidied SED</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>redshift</code></strong> :&ensp;<code>float</code></dt>
<dd>the redshift of the source</dd>
<dt><strong><code>nites</code></strong> :&ensp;<code>List[int]</code></dt>
<dd>a list of night relative to peak you want to obtain a magnitude for </dd>
<dt><strong><code>sed</code></strong> :&ensp;<code>None</code> or <code>pandas.DataFrame</code>, optional, default=<code>None</code></dt>
<dd>a dataframe containing the sed of the SN </dd>
<dt><strong><code>sed_filename</code></strong> :&ensp;<code>str</code></dt>
<dd>filename containing the time-series sed you want to use </dd>
<dt><strong><code>cosmo</code></strong> :&ensp;<code>astropy.cosmology</code></dt>
<dd>an astropy.cosmology instance used for distance calculations</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>lc_dict</code></dt>
<dd>a dictionary with keys ['lc, 'obj_type', 'sed']
- 'lc' contains a dataframe of the light from the object
- 'obj_type' contains a string for the type of object. Will always be <sed_filename> here
- 'sed' contains the filename of the sed used</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def gen_user(self, redshift, nites, sed=None, sed_filename=None, cosmo=None):
    &#34;&#34;&#34;
    Generate a light curve from a user-specidied SED

    Args:
        redshift (float): the redshift of the source
        nites (List[int]): a list of night relative to peak you want to obtain a magnitude for 
        sed (None or pandas.DataFrame, optional, default=None): a dataframe containing the sed of the SN 
        sed_filename (str): filename containing the time-series sed you want to use 
        cosmo (astropy.cosmology): an astropy.cosmology instance used for distance calculations

    Returns:
        lc_dict: a dictionary with keys [&#39;lc, &#39;obj_type&#39;, &#39;sed&#39;]
          - &#39;lc&#39; contains a dataframe of the light from the object
          - &#39;obj_type&#39; contains a string for the type of object. Will always be &lt;sed_filename&gt; here 
          - &#39;sed&#39; contains the filename of the sed used  
    &#34;&#34;&#34;
    if not sed:
        sed = self._read_sed(&#39;seds/user/&#39; + sed_filename)

    return self.gen_lc_from_sed(redshift, nites, sed, sed_filename, sed_filename, cosmo=cosmo)</code></pre>
</details>
</dd>
<dt id="deeplenstronomy.timeseries.LCGen.gen_variable"><code class="name flex">
<span>def <span class="ident">gen_variable</span></span>(<span>self, redshift, nites, sed=None, sed_filename=None, cosmo=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate a random variable light curve</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>redshift</code></strong> :&ensp;<code>float</code></dt>
<dd>ignored </dd>
<dt><strong><code>nites</code></strong> :&ensp;<code>List[int]</code></dt>
<dd>a list of night relative to peak you want to obtain a magnitude for
</dd>
<dt><strong><code>sed_filename</code></strong> :&ensp;<code>str</code></dt>
<dd>ignored</dd>
<dt><strong><code>cosmo</code></strong> :&ensp;<code>astropy.cosmology</code></dt>
<dd>ignored</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>lc_dict</code></dt>
<dd>a dictionary with keys ['lc, 'obj_type', 'sed']
- 'lc' contains a dataframe of the light from the object
<br>
- 'obj_type' contains a string for the type of object. Will always be 'Variable' here
- 'sed' contains the filename of the sed used. Will always be 'Variable' here</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def gen_variable(self, redshift, nites, sed=None, sed_filename=None, cosmo=None):
    &#34;&#34;&#34;
    Generate a random variable light curve

    Args:
        redshift (float): ignored 
        nites (List[int]): a list of night relative to peak you want to obtain a magnitude for    
        sed_filename (str): ignored
        cosmo (astropy.cosmology): ignored

    Returns:
        lc_dict: a dictionary with keys [&#39;lc, &#39;obj_type&#39;, &#39;sed&#39;]
          - &#39;lc&#39; contains a dataframe of the light from the object     
          - &#39;obj_type&#39; contains a string for the type of object. Will always be &#39;Variable&#39; here
          - &#39;sed&#39; contains the filename of the sed used. Will always be &#39;Variable&#39; here  
    &#34;&#34;&#34;
    output_data_cols = [&#39;NITE&#39;, &#39;BAND&#39;, &#39;MAG&#39;]
    output_data = []
    central_mag = random.uniform(12.0, 23.0)
    colors = {band: mag for band, mag in zip(self.bands, np.random.uniform(low=-2.0, high=2.0, size=len(self.bands)))}
    for nite in nites:
        central_mag = random.uniform(central_mag - 1.0, central_mag + 1.0)
        for band in self.bands:
            output_data.append([nite, band, central_mag + colors[band]])

    return {&#39;lc&#39;: pd.DataFrame(data=output_data, columns=output_data_cols),
            &#39;obj_type&#39;: &#39;Variable&#39;,
            &#39;sed&#39;: &#39;Variable&#39;}</code></pre>
</details>
</dd>
<dt id="deeplenstronomy.timeseries.LCGen.gen_variablenoise"><code class="name flex">
<span>def <span class="ident">gen_variablenoise</span></span>(<span>self, redshift, nites, sed=None, sed_filename=None, cosmo=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate a variable light curve with small random noise</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>redshift</code></strong> :&ensp;<code>float</code></dt>
<dd>ignored</dd>
<dt><strong><code>nites</code></strong> :&ensp;<code>List[int]</code></dt>
<dd>a list of night relative to peak you want to obtain a magnitude for</dd>
<dt><strong><code>sed_filename</code></strong> :&ensp;<code>str</code></dt>
<dd>ignored</dd>
<dt><strong><code>cosmo</code></strong> :&ensp;<code>astropy.cosmology</code></dt>
<dd>ignored</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>lc_dict</code></dt>
<dd>a dictionary with keys ['lc, 'obj_type', 'sed']
- 'lc' contains a dataframe of the light from the object
- 'obj_type' contains a string for the type of object. Will always be 'VariableNoise' here
- 'sed' contains the filename of the sed used. Will always be 'VariableNoise' here</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def gen_variablenoise(self, redshift, nites, sed=None, sed_filename=None, cosmo=None):
    &#34;&#34;&#34; 
    Generate a variable light curve with small random noise

    Args:
        redshift (float): ignored
        nites (List[int]): a list of night relative to peak you want to obtain a magnitude for
        sed_filename (str): ignored
        cosmo (astropy.cosmology): ignored

    Returns:
        lc_dict: a dictionary with keys [&#39;lc, &#39;obj_type&#39;, &#39;sed&#39;]
          - &#39;lc&#39; contains a dataframe of the light from the object
          - &#39;obj_type&#39; contains a string for the type of object. Will always be &#39;VariableNoise&#39; here
          - &#39;sed&#39; contains the filename of the sed used. Will always be &#39;VariableNoise&#39; here              
    &#34;&#34;&#34;
    noiseless_lc_dict = self.gen_variable(redshift, nites)
    noise = np.random.normal(loc=0, scale=0.25, size=noiseless_lc_dict[&#39;lc&#39;].shape[0])
    noiseless_lc_dict[&#39;lc&#39;][&#39;MAG&#39;] = noiseless_lc_dict[&#39;lc&#39;][&#39;MAG&#39;].values + noise
    noiseless_lc_dict[&#39;obj_type&#39;] = &#39;VariableNoise&#39;
    noiseless_lc_dict[&#39;sed&#39;] = &#39;VariableNoise&#39;
    return noiseless_lc_dict</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="deeplenstronomy" href="index.html">deeplenstronomy</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="deeplenstronomy.timeseries.LCGen" href="#deeplenstronomy.timeseries.LCGen">LCGen</a></code></h4>
<ul class="two-column">
<li><code><a title="deeplenstronomy.timeseries.LCGen.gen_cc" href="#deeplenstronomy.timeseries.LCGen.gen_cc">gen_cc</a></code></li>
<li><code><a title="deeplenstronomy.timeseries.LCGen.gen_flat" href="#deeplenstronomy.timeseries.LCGen.gen_flat">gen_flat</a></code></li>
<li><code><a title="deeplenstronomy.timeseries.LCGen.gen_flatnoise" href="#deeplenstronomy.timeseries.LCGen.gen_flatnoise">gen_flatnoise</a></code></li>
<li><code><a title="deeplenstronomy.timeseries.LCGen.gen_ia" href="#deeplenstronomy.timeseries.LCGen.gen_ia">gen_ia</a></code></li>
<li><code><a title="deeplenstronomy.timeseries.LCGen.gen_kn" href="#deeplenstronomy.timeseries.LCGen.gen_kn">gen_kn</a></code></li>
<li><code><a title="deeplenstronomy.timeseries.LCGen.gen_lc_from_sed" href="#deeplenstronomy.timeseries.LCGen.gen_lc_from_sed">gen_lc_from_sed</a></code></li>
<li><code><a title="deeplenstronomy.timeseries.LCGen.gen_static" href="#deeplenstronomy.timeseries.LCGen.gen_static">gen_static</a></code></li>
<li><code><a title="deeplenstronomy.timeseries.LCGen.gen_user" href="#deeplenstronomy.timeseries.LCGen.gen_user">gen_user</a></code></li>
<li><code><a title="deeplenstronomy.timeseries.LCGen.gen_variable" href="#deeplenstronomy.timeseries.LCGen.gen_variable">gen_variable</a></code></li>
<li><code><a title="deeplenstronomy.timeseries.LCGen.gen_variablenoise" href="#deeplenstronomy.timeseries.LCGen.gen_variablenoise">gen_variablenoise</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>